# Git

## 前置き

* Git は元々 Linux kernel の開発のために Linus によって開発された。
  * 当時使っていた BitKeeper というプロプライエタリなバージョン管理ソフトで
    トラブルがあったため。
  * プログラムのソースコードのような単純なテキストファイルとの相性が非常によい。
  * 画像動画その他のきらびやかなファイルは歴史データがかさばりよろしくない。
    * git lfs で検索。
* コンソール・テキストファイル・テキストエディタ・Linux 至上主義が源流にあるため、
  そのあたりは理解しつつ温かい目で見ること。
  * オリジナルの開発者が Linux kernel の開発者だから。
  * いろいろな人々の長きに渡る努力でいろいろな部分がマシになってきた。
  * Windows で事故っても怒らない。
* Git が主流になってから 10 年以上？変わる気配がないので諦めること。
  もしくは、自分で作る。
  * Git の代わりを作るよりは、よりフレンドリーな GUI / Web UI を作る方に
    注力するようになったと言えるのかもしれない。
* Linux は相当大規模なプロジェクトなので、よほどのプロジェクト規模でない限り
  使わないだろうという機能もある。そういうものは気にしなくてよし。

プログラムのソースコード以外に相性のよいもの

* 本の原稿
* 卒業論文

この2つに関しては非常にオススメです。
ただし、Git 自体の習得コストがどうしてもネックになることが多いので、
論文執筆のシーズンに入る前に1か月くらい Git で遊んでみることを強くお勧めします。
**シーズンになるとサーバも自分の PC もよりによってこの時期に壊れます。**
ジンクスとかそういうものではなく、その時期にコンピュータを酷使するからです。
手癖のように `git push` で別の物理マシンとの間でリポジトリごと同期しておくと
トラブル時に非常に速やかに対処できます。
編集履歴が自動で全部記録されていつでも戻せるので大変更の保険もバッチリです。

## ヘルプ

```sh
git help CMD
git CMD --help
```

## リポジトリ

これまでの全ての更新履歴を含むデータが入ったもの。
大雑把に言うと `.git/` ディレクトリとほぼ同義。
`.git/` の中身が具体的にどうなっているのか漁って回るタイプの人間が作っているので
そういうものだと思っておくこと。

Git は (他のバージョン管理システムと比較して) **分散型** と呼ばれる。
ローカルマシンにもリモートサーバにも同じようにこれまでの履歴全体を保管する構造に
なっている。
これは最初のコマンドが `git clone` という名前の通り、リポジトリをサーバから
丸ごとコピーすることからも分かる。
ただし設計上対等とはいえ、サーバ側でよくある使い方とクライアント側でよくある使い方は
存在し、異なる。

(Git 一択になっている現状、知る必要はないが)
分散型でない中央集権型のシステム (CVS, SVN) では、サーバに全ての履歴を保管し、
クライアントは必要なデータのみをサーバからダウンロードするような仕組みになっていた。
ネットワーク速度やクライアントマシンのディスク容量に余裕が出てきたから
可能になったスタイルとも言える。

### git init

ディレクトリを git リポジトリとして初期化する。
実行後、`.git/` という名前の隠しディレクトリができている。
この中に全履歴が保存されていく。

実は、あまり使わない…。
大抵の場合、共有サーバ等のリモートのリポジトリを clone して始めることの方が多い。
clone した場合は自動でその clone 元が `origin` という名前で登録される。

```sh
git init --bare
```

主にサーバ的に使うコンピュータ上で初期化するためのコマンド。
ワーキングコピー
(作業用に、ある時点のファイルセットを普通に編集できる形で展開したもの)
を作らない。純粋に履歴の保管庫 (push/fetch のため) としてのみ運用する
リポジトリとして初期化する。
ベア (裸の) リポジトリと呼ばれる。

### git clone

いつもの。

```sh
git clone <repo> [<dir>]
```

リポジトリのアドレスの最後の部分が自動的にディレクトリ名として使われるが、
後ろに追加で指定するとディレクトリ名を好きなものに変えることができる。

```sh
$ git remote -v
origin  https://github.com/yappy/grimoire.git (fetch)
origin  https://github.com/yappy/grimoire.git (push)
```

clone 元のアドレスが自動的に `origin` という名前の remote として登録される。
手動で登録するのは面倒なので clone 推奨。
ただし `origin` というデフォルトネームはリモート関連のコマンドが何をやっているのか
理解するためには覚えておいた方がよい。

```sh
$ git branch -a
  gh-pages
* main
  remotes/origin/HEAD -> origin/main
  remotes/origin/gh-pages
  remotes/origin/main
```

リモートトラッキングブランチも `remotes/(リモート名)/(ブランチ名)` という名前で
自動的に作られる。
これは名前の通り、リモートリポジトリの変更を追跡するためのブランチで、
リモートブランチの丸々コピーを表す。
このあたりを知っておくと fetch, push のやっていることが分かりやすい。

昨今のソフトウェアの肥大化は留まることを知らず、プロジェクトによっては
リポジトリが肥大化しており clone にとてつもない時間がかかることがある。
場合によっては昔の全履歴は必要ないということもあるだろうから、
clone には豊富なオプションが用意されている。

* `depth=1` shallow clone (浅いクローン)
  * ~~他は難しくて覚えられない。~~
  * 制限が多く罠だらけの状態になるので最新の状態を閲覧したいだけの時以外は
    使わない方がよい。
* partial clone
  * ブロブレスクローンとツリーレスクローンがあるらしい。
  * シャロークローンより制限が緩いようだが、中途半端なのでフルクローンすれば
    いいんじゃないかと思う。
  * ~~一晩寝て待っていれば終わるよ。~~
  * ~~豊かなディスク容量とネットワーク帯域でゴリ押すのが現代の
    ソフトウェアエンジニアリングだよ~~

### いつもの新規作成手順

1. GitHub の web UI でリポジトリを新規作成する。
1. これは GirHub のサーバ上で `mkdir` して `git init --bare` することに相当する。
  ついでに README 等を最初のコミットとして入れてくれる。
1. web UI で見えるアドレスをコピー。
1. ローカルで `git clone <コピーしたアドレス>`
1. 完了。これだけ！

## ローカルの作業

ローカルリポジトリに対して編集を行う方法。

### ワークツリーとステージング

`--bare` でない Git リポジトリのディレクトリには、
リポジトリ内の履歴の今いる時点の内容が、
普通に編集できるディレクトリやファイルの形で展開されている。
これをワークツリーとかワーキングコピーと呼んでいる。

これを書き換えてコミット (履歴の一時点として登録) するわけだが、
その前にコミットに含めたい変更のみを置くための場所がインデックス
(名前が分かりづらい気がする。。) とかステージングエリアなどと呼ばれる場所である。

変更量が多かったり、一度に論理的に複数の変更をしてしまったため
コミットを分けたい場合に便利である。
そうでない場合は面倒なだけだが、多少ショートカットできるオプションもある。

### コミットの指定

全てのコミットにはハッシュがついており、これを使って特定のコミットを
指定することができる。
このハッシュには SHA-1 が使われており、計算元のデータには Author や Date 等の
文字列も含めているためそれらが少しでも変わると全く違う値になる。
これは全てのコミット間で異なることを前提に組まれているため、
天文学的に運が悪いとシステムが破綻するが気にしなくてよい。
ハッシュはほとんどの場合最初の方だけでも他と被らないので、
一意に判別できるなら最初の6ケタ程度でも認識される。

```sh
$ git log
commit 987e4e5a09483b952bac7a0dfcd64970905fe7d9 (HEAD -> main)
Author: yappy <superunyo@yahoo.co.jp>
Date:   Wed Dec 25 01:02:17 2024 +0900

    Install mdbook-mermaid
```

### git status

**とにかくこれ。**
ここからやりたくなる操作についてどのようなコマンドを打てばいいかもかなり親切に
教えてくれる。

```sh
git status
```

例

```sh
$ git status
# 現在いるブランチ名
On branch main
# リモートトラッキングブランチとの比較
# 自分の方が1つコミットが多いところにいるので、これをリモートに送りたいなら
# git push でできるよ
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)
# ステージ中の変更
# このまま git commit した時にコミットされる内容
# git restore --staged で戻せるよ
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   README.md
        modified:   src/SUMMARY.md
        new file:   src/git.md
# ステージされていない変更
# git add でステージできるよ
# git restore で変更を破棄 (現在いるコミットの内容に戻す) できるよ
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   src/git.md

```

### git diff

コミットと

### git add

```sh
git add <file/dir>
```

* git 管理下のファイルの場合、変更をステージングする。
* git 管理下でない場合、ファイルの追加をステージングする。
* ディレクトリを指定すると、そのディレクトリ以下の全ファイルに上記を適用する。

やっぱりやめたいときは `git status` を見る。

```sh
git add -p <path>
```

中級コマンド。
1つのファイル内の差分を部分的にステージする。
Yes/No/もっと細かく分割、で答えていくことで好きな部分だけステージする
(他の部分は別のコミットとする) ことができる。

### git rm
