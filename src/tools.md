# サバイバルツール類

## よく分からないファイルを調べる

ヘッダ情報をパースしてくれたり、テキストファイルならエンコーディングを調べてくれたり、
既に種類が分かっているファイル相手でもいい感じで要約された情報が得られる。

```sh
$ file rshanghai
rshanghai: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID[sha1]=82b09bf2c510acc4e66f5a8bd9b65d0120968da6, for GNU/Linux 3.7.0, not stripped

$ file yappy_house_full.jpg
yappy_house_full.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 350x350, segment length 16, Exif Standard: [TIFF image data, big-endian, direntries=14], baseline, precision 8, 3118x3118, components 3

$ file src/tools.md
src/tools.md: Unicode text, UTF-8 text
```

## バイナリファイルのうち文字列として解釈可能な部分を表示

何らかの手掛かりを得たい場合や、
バイナリファイルに流出するとまずい情報が含まれていないか調べる時などに。

`-n <文字数>` で最低文字列長を指定できる。
デフォルトは 4 らしい。

```sh
$ strings rshanghai
/lib/ld-linux-aarch64.so.1
_ITM_deregisterTMCloneTable
__gmon_start__
_ITM_registerTMCloneTable
SSL_get_verify_result
SSL_shutdown
SSL_CTX_new
SSL_set_verify
SSL_get0_param
SSL_CTX_get_cert_store
...
```

## バイナリ表示

```sh
$ xxd rshanghai | head
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0300 b700 0100 0000 c070 1a00 0000 0000  .........p......
00000020: 4000 0000 0000 0000 6831 0302 0000 0000  @.......h1......
00000030: 0000 0000 4000 3800 0a00 4000 2000 1f00  ....@.8...@. ...
00000040: 0600 0000 0400 0000 4000 0000 0000 0000  ........@.......
00000050: 4000 0000 0000 0000 4000 0000 0000 0000  @.......@.......
00000060: 3002 0000 0000 0000 3002 0000 0000 0000  0.......0.......
00000070: 0800 0000 0000 0000 0300 0000 0400 0000  ................
00000080: 7002 0000 0000 0000 7002 0000 0000 0000  p.......p.......
00000090: 7002 0000 0000 0000 1b00 0000 0000 0000  p...............

$ xxd -g 1 rshanghai | head
00000000: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 03 00 b7 00 01 00 00 00 c0 70 1a 00 00 00 00 00  .........p......
00000020: 40 00 00 00 00 00 00 00 68 31 03 02 00 00 00 00  @.......h1......
00000030: 00 00 00 00 40 00 38 00 0a 00 40 00 20 00 1f 00  ....@.8...@. ...
00000040: 06 00 00 00 04 00 00 00 40 00 00 00 00 00 00 00  ........@.......
00000050: 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  @.......@.......
00000060: 30 02 00 00 00 00 00 00 30 02 00 00 00 00 00 00  0.......0.......
00000070: 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  ................
00000080: 70 02 00 00 00 00 00 00 70 02 00 00 00 00 00 00  p.......p.......
00000090: 70 02 00 00 00 00 00 00 1b 00 00 00 00 00 00 00  p...............

# エンディアンのせいで変。。
$ hexdump rshanghai | head
0000000 457f 464c 0102 0001 0000 0000 0000 0000
0000010 0003 00b7 0001 0000 70c0 001a 0000 0000
0000020 0040 0000 0000 0000 3168 0203 0000 0000
0000030 0000 0000 0040 0038 000a 0040 0020 001f
0000040 0006 0000 0004 0000 0040 0000 0000 0000
0000050 0040 0000 0000 0000 0040 0000 0000 0000
0000060 0230 0000 0000 0000 0230 0000 0000 0000
0000070 0008 0000 0000 0000 0003 0000 0004 0000
0000080 0270 0000 0000 0000 0270 0000 0000 0000
0000090 0270 0000 0000 0000 001b 0000 0000 0000

# -C でいい感じになる
$ hexdump -C rshanghai | head
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  03 00 b7 00 01 00 00 00  c0 70 1a 00 00 00 00 00  |.........p......|
00000020  40 00 00 00 00 00 00 00  68 31 03 02 00 00 00 00  |@.......h1......|
00000030  00 00 00 00 40 00 38 00  0a 00 40 00 20 00 1f 00  |....@.8...@. ...|
00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000050  40 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |@.......@.......|
00000060  30 02 00 00 00 00 00 00  30 02 00 00 00 00 00 00  |0.......0.......|
00000070  08 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00  |................|
00000080  70 02 00 00 00 00 00 00  70 02 00 00 00 00 00 00  |p.......p.......|
00000090  70 02 00 00 00 00 00 00  1b 00 00 00 00 00 00 00  |p...............|

# octal dump なのでデフォルトは8進数になる
$ od rshanghai | head
0000000 042577 043114 000402 000001 000000 000000 000000 000000
0000020 000003 000267 000001 000000 070300 000032 000000 000000
0000040 000100 000000 000000 000000 030550 001003 000000 000000
0000060 000000 000000 000100 000070 000012 000100 000040 000037
0000100 000006 000000 000004 000000 000100 000000 000000 000000
0000120 000100 000000 000000 000000 000100 000000 000000 000000
0000140 001060 000000 000000 000000 001060 000000 000000 000000
0000160 000010 000000 000000 000000 000003 000000 000004 000000
0000200 001160 000000 000000 000000 001160 000000 000000 000000
0000220 001160 000000 000000 000000 000033 000000 000000 000000

# 16進デフォルトは 16 bit ごとの上にエンディアンのせいで変。。
$ od -x rshanghai | head
0000000 457f 464c 0102 0001 0000 0000 0000 0000
0000020 0003 00b7 0001 0000 70c0 001a 0000 0000
0000040 0040 0000 0000 0000 3168 0203 0000 0000
0000060 0000 0000 0040 0038 000a 0040 0020 001f
0000100 0006 0000 0004 0000 0040 0000 0000 0000
0000120 0040 0000 0000 0000 0040 0000 0000 0000
0000140 0230 0000 0000 0000 0230 0000 0000 0000
0000160 0008 0000 0000 0000 0003 0000 0004 0000
0000200 0270 0000 0000 0000 0270 0000 0000 0000
0000220 0270 0000 0000 0000 001b 0000 0000 0000

$ od -t x1 rshanghai | head
0000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
0000020 03 00 b7 00 01 00 00 00 c0 70 1a 00 00 00 00 00
0000040 40 00 00 00 00 00 00 00 68 31 03 02 00 00 00 00
0000060 00 00 00 00 40 00 38 00 0a 00 40 00 20 00 1f 00
0000100 06 00 00 00 04 00 00 00 40 00 00 00 00 00 00 00
0000120 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00
0000140 30 02 00 00 00 00 00 00 30 02 00 00 00 00 00 00
0000160 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00
0000200 70 02 00 00 00 00 00 00 70 02 00 00 00 00 00 00
0000220 70 02 00 00 00 00 00 00 1b 00 00 00 00 00 00 00
```

コマンドラインパラメータを覚えられないので、デフォルトで見やすい `xxd` を
第一選択肢に覚えておくのがいい気がする。
コマンド名の覚えやすさで行くなら `hexdump -C`。

なんでいろいろあるの？

* xxd は vim についてくるツールらしい。
* hexdump は BSD 由来で Linux にも入っている系らしい。
* od は由緒正しく POSIX でも規定されているコマンドらしい。
  * 由緒正しすぎて 8 進ダンプは現代ではほぼ使われないのではないかとも思う。

## バイナリファイルを編集する

`xxd` が vim についてくるというのはこうやって使えということらしい。
~~やったことがない。~~
`xxd -r` でテキストダンプからバイナリに逆変換できる。

```sh
$ vi -b file.bin
:%!xxd
:%!xxd -r
:wq
```

## バイナリファイルを C ヘッダに変換する

こういうのでいいんだよこういうので。
圧倒的なポータビリティを誇る。

```sh
$ xxd -i rshanghai | head
unsigned char rshanghai[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xb7, 0x00, 0x01, 0x00, 0x00, 0x00,
  0xc0, 0x70, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x68, 0x31, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x0a, 0x00, 0x40, 0x00,
  0x20, 0x00, 0x1f, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00,

# -C で変数名を大文字に
# -name で変数名を変更
$ xxd -i -C -name myname rshanghai | head
unsigned char MYNAME[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xb7, 0x00, 0x01, 0x00, 0x00, 0x00,
  0xc0, 0x70, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x68, 0x31, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x0a, 0x00, 0x40, 0x00,
  0x20, 0x00, 0x1f, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00,
```

## バイナリファイルをオブジェクトファイルに変換してリンクする

objcopy はオブジェクトファイルのコピーを行うが、ただのフルコピーなら `cp` コマンドで
いい訳で、実質的にフォーマット変換コマンドである。
`-I` や `-O` で入出力フォーマットを指定できるが、ここに `binary` が指定可能である。

```sh
# -B を指定しないとリンカエラーになる気がする
$ objcopy -I binary -O elf64-little yappy_house.jpg  yappy_house.o
```

デフォルトだと `.data` (読み書き可能グローバル変数領域) セクションに
配置されてしまうので、気になるなら `--rename-section` を使う。
man に例があるので
`--rename-section .data=.rodata,alloc,load,readonly,data,contents`
をコピーして使えばよさそう。

```sh
$ man objcopy
--rename-section oldname=newname[,flags]
    Rename a section from oldname to newname, optionally changing the section's flags to flags in the process.
    This has the advantage over using a linker script to perform the rename in that the output stays as an
    object file and does not become a linked executable.  This option accepts the same set of flags as the
    --sect-section-flags option.

    This option is particularly helpful when the input format is binary, since this will always create a
    section called .data.  If for example, you wanted instead to create a section called .rodata containing
    binary data you could use the following command line to achieve it:

              objcopy -I binary -O <output_format> -B <architecture> \
              --rename-section .data=.rodata,alloc,load,readonly,data,contents \
              <input_binary_file> <output_object_file>
```

オブジェクトファイルには以下のようなシンボルが定義される。

```sh
$ nm yappy_house.o
00000000000218b7 D _binary_yappy_house_jpg_end
00000000000218b7 A _binary_yappy_house_jpg_size
0000000000000000 D _binary_yappy_house_jpg_start

# リンク後
$ nm a.out | grep _binary
00000000000418ef D _binary_yappy_house_jpg_end
00000000000218b7 A _binary_yappy_house_jpg_size
0000000000020038 D _binary_yappy_house_jpg_start
```

size は分かりづらいが、absolute シンボルとして定義され、リンクしても値が変わらない。
シンボルアドレスがファイルサイズになっている。
なので奇数サイズのファイルの場合、奇数アドレスのシンボルができる。気持ち悪い。
1 byte 型のポインタとして `end - start` を計算すれば出てくるので、
size は使わなくてもいいかもしれない…。

C 以外で用意したシンボルを C から参照する際は型で混乱しやすいので注意。
シンボル情報のレベルでは型情報が消えているので無難な 1 byte 型にしてやるとよい。

```C
// unsigned char _binary_yappy_house_jpg_start[SIZE] = {...};
// を定義すると
// "_binary_yappy_house_jpg_start"
// という配列の先頭アドレスを指すシンボルが生成されると考える
extern const unsigned char _binary_yappy_house_jpg_start[];
extern const unsigned char _binary_yappy_house_jpg_end[];
```
