# インラインアセンブラ

C/C++ ソースの中にアセンブラを埋め込める。
C コードの途中にだいたいどこでも埋め込めるため、気軽にアセンブラ入門できる。

* アセンブラのソースファイルを用意する、ビルドシステムを整備するのが面倒。
* 関数の引数や返り値、スタックの処理は C に任せたい。

こんな時におすすめ。
C の `main()` を呼ぶ前のスタートアップルーチンはアセンブラのソースファイルを
用意した方がいいかも。

## 注意

* アセンブリ命令は機械語と対応しているので他ハードウェアへの移植性は諦めること。
* AT&T 表記の GAS (GNU Assembler) と Intel 表記の MASM
  (Microsoft Macro Assembler) でオペランドの src と dst の順番が逆という
  とんでもない罠があるので注意。
* CPU が同じなら同じ命令が使えるはずというのはともかく、アセンブラへの命令は
  標準仕様もクソもありません。そういうのは諦めてください。
* 互換性とか一般性とかは捨てる必要があるので、GAS を説明します。
  これが分かれば他でも生き延びられる。

## GAS (GNU ASsembler)

多分新しそうなマニュアルへのリンク

<https://sourceware.org/binutils/docs/as/>

```sh
# コマンド名は as
# 通常は gcc から自動で呼ばれる
as --version
```

## C コンパイル (広義) の流れ

1. C ソース (*.c)
1. プリプロセス (#include や #define 等を処理する)
1. プリプロセス済み C ソース
1. コンパイル (狭義) (C をアセンブラに変換する)
1. アセンブリソース (*.s)
1. アセンブル (アセンブラを機械語に変換する)
1. オブジェクトファイル (*.o) (機械語だが、外部グローバル変数や関数への参照が未解決)
1. リンク
1. 実行可能ファイル or ライブラリファイル

ちなみにコンパイラを自作する場合はアセンブラを出力してアセンブルとリンクを
既存ツールに任せると楽。Rust もそうしている。

## 関連コマンド

実行可能ファイルまでリンクせず、オブジェクトファイル `*.o` の生成までで止める。

```sh
gcc -c src.c
```

C コンパイルの後、アセンブラの生成で止める。拡張子は `*.s`。
これをアセンブルすると `*.o` ができる。

```sh
gcc -S src.c
```

gcc は C コンパイラではなく総合フロントエンドなので、アセンブルしたいなら
`*.s` ファイルをそのまま渡せばよい。

```sh
# make src.o (not an execuable)
gcc -c src.s
```

プリプロセスで止める。

```sh
gcc -E src.c
```

オブジェクトファイルをディスアセンブルする。

```sh
objdump -d src.o
```

## 例

C ソース

```c
#include <stdio.h>

int main() {
        puts("hello");
        return 0;
}
```

機械語とディスアセンブル

```text
$ gcc -O3 -g0 src.c
$ objdump -d src.o

src.o:     file format elf64-x86-64


Disassembly of section .text.startup:

0000000000000000 <main>:
   0:   48 83 ec 08             sub    $0x8,%rsp
   4:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # b <main+0xb>
   b:   e8 00 00 00 00          call   10 <main+0x10>
  10:   31 c0                   xor    %eax,%eax
  12:   48 83 c4 08             add    $0x8,%rsp
  16:   c3                      ret
```

コンパイラの吐いたアセンブリソース

```asm
        .file   "src.c"
        .text
        .section        .rodata.str1.1,"aMS",@progbits,1
.LC0:
        .string "hello"
        .section        .text.startup,"ax",@progbits
        .p2align 4
        .globl  main
        .type   main, @function
main:
.LFB11:
        .cfi_startproc
        subq    $8, %rsp
        .cfi_def_cfa_offset 16
        leaq    .LC0(%rip), %rdi
        call    puts@PLT
        xorl    %eax, %eax
        addq    $8, %rsp
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE11:
        .size   main, .-main
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"
        .section        .note.GNU-stack,"",@progbits
```

謎の呪文が多くて気持ち悪くなるが、そういうところはコンパイラに任せて
インラインアセンブラを使おう。

抵抗感を軽減するための解説

* .file とかのドットで始まる指令
  * ディレクティブと呼ばれるもので、機械語命令を置くのではなく
    アセンブラへの指令を出せる。マニュアルを検索すると出てくるはず。
  * .section
    * elf (オブジェクトファイルや実行可能ファイルのフォーマット) の
      どの名前のセクションに入れるかを指定する。
      * text: プログラムコードを入れるセクション。思いっきり機械語のバイナリが
        入っているので、名前がミスリーディング。
        名前の由来はよく分からない。
      * data: グローバル変数が入っている。
        elf ファイルに初期値イメージが入っている。
      * bss: ゼロ初期化されるグローバル変数が入っている。
        elf ファイルにデータのコピーが入っておらず、メモリレンジの情報だけが入る。
        main() 関数に入る前にゼロフィルする必要がある。
      * rodata: Read Only DATA。data のリードオンリー版。
        文字列リテラルの本体もここに入る。
  * .string
    * 文字列データをここに置く。他にも `.byte` `.word` などで定数リテラルを
      そのまま置ける。
  * .globl
    * シンボルをグローバルにする。要は他のオブジェクトファイルとリンクできるようにする。
      C で言うと static のついていないグローバル変数・関数にする。
      ~~なんで C はデフォルトが外部リンケージなんだ。~~
  * .cfi_* 系
    * 謎のデバッグ用情報。あまり気にしなくてよし。
  * .include, .incbin
    外部ファイルを読み込んでインクルードする。
    なんと外部バイナリを読んでその場所に置ける。
* インデントなしでコロンで終わっている識別子
  * ラベル。アドレスとして本文から参照できる。
  * 他のオブジェクトファイルに公開したい場合は .globl を使う。
* インデントされていてドットで始まっていないもの
  * CPU 命令。
  * …と見せかけて疑似命令 (1つ、または複数の CPU 命令に変換される
    アセンブラ提供の便利機能) のこともある。
  * 疑似命令は逆アセンブルすると正体を現すかもしれないし、逆アセンブラが気を利かせて
    疑似命令で表示してくれるかもしれない。
  * なんだか疑似命令をディレクティブのこととして説明している文書も多く見つかるが、
    そもそも情報少なすぎるし細かいことは気にしなくていいです。

## インラインアセンブラの書き方

多分新しそうなマニュアルへのリンク

<https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html>

アセンブラが機械語と一対一だというのが妄言だと理解したら、
インラインアセンブラの移植性皆無で超絶便利な機能を理解する準備ができたといえる。

アセンブラが扱うのはレジスタだが、C では変数という抽象的な概念を操作している。
アセンブラを書くとなると C との間で変数の受け渡しが非常にしたくなるところだが、
インラインアセンブラの文法はこの受け渡しをきれいに行ってくれる。
また、レジスタ入出力の依存性をしっかり書けば、最適化の恩恵を受けることもできる
(volatile で拒否することもできる)。

```C
asm volatile ("template" : output : input : clobber);
```

* volatile
  * これをつけないと入力レジスタから出力レジスタを生成するだけの命令列として
    最適化の対象になるが、これをつけるとこの最適化を無効にする。
  * 副作用のある命令を書く場合は必ず必要。
* template
  * アセンブラのテンプレート。
    ここから特定の文字列を入出力レジスタ名に自動で置換してくれたりする。
* output
  * 出力オペランド指定。
* input
  * 入力オペランド指定。
* clobber
  * このアセンブラで破壊されるレジスタ。
  * "memory" を指定するとメモリの読み書きを行うことをコンパイラに通知する。
    実質的にコンパイラに対するメモリバリアとなる
    (このアセンブラをまたいだメモリ読み書き命令の並べ替え抑止)。
    プロセッサによる投機実行は防げない。

マニュアル中の例。

```C
void do_print(uint32_t dwSomeValue)
{
   uint32_t dwRes;

   for (uint32_t x=0; x < 5; x++)
   {
      // Assumes dwSomeValue is not zero.
      asm ("bsfl %1,%0"
        : "=r" (dwRes)
        : "r" (dwSomeValue)
        : "cc");

      printf("%u: %u %u\n", x, dwSomeValue, dwRes);
   }
}
```

* bsfl は x86 の Bit Scan Forward 命令で、1が立っているビットの中で最下位のものの
  インデックスを返す命令らしい。
* テンプレート文字列中の `%0` や `%1` は、続く入出力オペランド指定で渡された
  値に該当する文字列に置換される。
  * ここでは C の引数やローカル変数をレジスタ指定で与えているため、
    コンパイラの決めたレジスタ名に置換される。
* 出力オペランドを `"=r" (dwRes)` のように記述することで、C のローカル変数 `dwRes` に
  対応するレジスタに値が書き込まれることをコンパイラに伝えることができる。
  * `=` は書き込みを示す。
  * `r` は値のタイプで、レジスタを示す。ここを変えれば即値を渡せたりもする、と思う。
* 入力オペランドも同様。
  * C 引数の `dwSomeValue` の値が入ったレジスタ名で `%1` が置換される。
* 最後の `"cc"` は x86 のフラグレジスタが破壊されることを示す。

この入出力オペランド制約では、ループ中で5回呼び出す意味はないと判断され、
コンパイラによってループの外に出される可能性がある。
それを防ぎたいならば、`asm volatile` とする必要がある (volatile 変数と同じ)。

ただし volatile 変数と同じく、asm volatile をまたいで他の命令が移動される
ことはあり得る (volatile 同士の順番は保存されたはず)。
以下のマニュアルの例では、浮動小数点丸めモードのコントロールレジスタの後に
演算が行われることを保証するために、`sum` への書き込み依存を追加している。
`%0` は現れていないため実際には書き込まれないが、コンパイラは
`sum = x + y` という `sum` への書き込みを上に移動することはできなくなる
(`sum` の結果が変わってしまうように見えるため)。

```C
asm volatile ("mtfsf 255,%1" : "=X" (sum) : "f" (fpenv));
sum = x + y;
```

このように、文法が覚えづらいとか、資料が少なすぎるとか、互換性汎用性が皆無とか、
CPU 固有のオプションがいっぱいあるとかを我慢すれば、C コードとの間の値の受け渡しを
かなりスムーズに実現できる。
素のアセンブリで関数を書くと、呼び出し規約を読みながら引数と返り値がどこに置かれるかで
苦労するし、そもそもインライン化して関数コールのオーバーヘッドを消したいという
ケースも多いかもしれない。
