# Git

## Git の内部実装

Git は他のファイルシステムの上で作られた、ユーザランドファイルシステムの一種である。
`git add` `git commit` のようなコマンドはハイレベルな抽象コマンドで、
よりローレベルなファイルシステム操作用のコマンドも存在している。

## Git Object

それぞれの commit に SHA-1 ハッシュが付与されており、コミットハッシュで
特定のコミットを一意に示すことができるのはよく知られているが、
そのコミットを構成する要素にもまたハッシュが付与されている。
グラフ理論で言うとループのない有向グラフとなる。

* blob
  * ファイルデータ (ファイル名は含まない)
* tree
  * blob と tree (再帰的) からなるディレクトリツリー構造
* commit
  * tree とコミット情報からなるディレクトリツリーのスナップショット
* tag
  * 特定のコミットへの参照

### blob

リンク構造のリーフノードとなるような末端のオブジェクトで、ファイルの内容を表す。
ファイル名の情報は含まない。
ヘッダのフォーマットはテキスト形式で、`blob` という文字列、スペース、
ファイルサイズを文字列で、そしてヌル文字 (1 byte のゼロ)で区切って
以下ファイルのバイナリデータが続く。

例: `blob 6\0Hello!`

そしてこのヘッダを含むデータ全体に対して SHA-1 hash を計算する。
SHA (Secure Hash Algorithm) はセキュアなハッシュアルゴリズムだが、
セキュリティというよりはヘッダも含めて 1 byte でも違えば全く異なる値になる点、
出力空間全体にまんべんなくランダムに散らばるように見える点を生かしていると思われる。
SHA-1 は 16 進数で 40 文字になる。

```c
hash = sha1("blob 6\0Hello!")
```

オブジェクトのハッシュが求まったら、`.git/objects` に以下のようなパスで保存される。
また、この時 zlib 圧縮 (zip みたいな可逆圧縮) がなされる。
これは blob に限らない。

`.git/objects/{最初の2文字}/{残りの38文字}`

ここから以下のようなことが分かる。

* 全く同一の内容 (ファイル名は問わない) のファイルの場合、ヘッダも含めてハッシュ計算の
  ソースが完全に一致するため、ハッシュも同一値になる。
  * 新たにオブジェクトを保存する必要はなく、されない。
* 運悪く異なるオブジェクトのハッシュ値が衝突してしまった場合、システムは破綻する。
  * 天文学的に低い確率なので無視できる。そういう設計のために SHA-1 を使っている。
  * ハッシュテーブルで文字列を管理する時のようないい加減なノンセキュアハッシュだと
    できやすい・できにくいハッシュ値に偏りがあって衝突しやすくなりそう。

### tree

例を見た方が早い。

```sh
$ git cat-file -p <hash>
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
```

実際のバイナリフォーマットは以下のようになっている。

* "tree"
* スペース
* サイズを文字列で
* NUL
* 中身...

tree の場合、中身のフォーマットは

* `[mode] [file/folder name]\0[SHA-1 of referencing blob or tree]`

らしい。
hash はバイナリで、固定長のため次のエントリへの区切り文字は不要らしい。
これがファイルかディレクトリかはそのハッシュからオブジェクトを引けば分かる。
また、ファイル名、ディレクトリ名の情報はここで付与される。

タイプを文字列で、スペース、サイズ、NULL 文字、サイズで指定された大きさの中身、
というのが git オブジェクトの共通のヘッダ及び全体の仕様となっている。
ヘッダも含めた全体に SHA-1 ハッシュ関数を適用し、その値から
`.git/objects/` 以下のパスを決定し保管されるのも同様である。

tree は blob または tree を任意の個数持つ、という再帰データ構造になっているので、
ファイルディレクトリツリーのある時点でのスナップショットを表すことになる。
ファイル or ディレクトリ名の変更で tree オブジェクトハッシュは変わるし、
ファイル内容 (blob) が変わるとそのハッシュが変わるので、それが書かれた
tree オブジェクトのハッシュも変わることになる (別オブジェクトとなる)。

### commit

tree によってある時点のディレクトリツリーのスナップショットが作れれば
コミットオブジェクトはとても簡単で、コミットとはある時点での
ファイルディレクトリツリーのスナップショットを指すのだから、
ある1つの tree オブジェクトへのリンクが本体である。
それにコミットメッセージや作者、コミット日時などのメタ情報を含めたものが
コミットオブジェクトである。

```sh
$ git cat-file -p <hash>
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon <schacon@gmail.com> 1243040974 -0700
committer Scott Chacon <schacon@gmail.com> 1243040974 -0700

first commit
```

これも実際はヌル文字を含むフォーマットであり先頭に共通のヘッダが付与され、
全体に SHA-1 を適用してハッシュが求められる。
これが `git log` でいつも目にする "コミットハッシュ" である。

マージコミットは少し特殊で、親コミットが2つになることがある。

### tag

`git tag -a` のアノテートタグは、tag というタイプの git object が作られる。
したがってタグにハッシュもつく。

```sh
git cat-file -p <hash>
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700

test tag
```

コミットへの参照が本体で、他にタグ名、作者、日時、タグメッセージなどが
含まれている。
ちなみにタグはコミット以外の任意の git object に対して作ることができるらしい。

軽量タグは単なるコミットへの参照であり、git object は作られない。

## まとめ

Git の設計は上層と下層に分かれている。

下層は、ヘッダとコンテンツから SHA-1 ハッシュを計算し、ハッシュをキーとした
リポジトリデータベースへ格納、また逆にハッシュからコンテンツを引くことのできる、
(カーネルファイルシステム上に構築された) ユーザランドファイルシステムになっている。

上層は、そのハッシュベースのファイルシステムをうまく使って
バージョンコントロールシステムを構築している。

Linux カーネル開発者作らしいというか、ある種の素養がないとひらめくのは難しいが、
一度理解してしまえばシンプルで一貫した設計で、
他にも応用の効きそうな興味深い設計である。

スナップショットに対応したジャーナリングファイルシステムのような
リッチなファイルシステムについて調べてみるのもよいかもしれない。
(すみません、私は組み込み志向なので勉強不足です)
