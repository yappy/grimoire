<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3日ではなれないかもしれない人形遣い</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">3日ではなれないかもしれない人形遣い</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="nandgame-攻略"><a class="header" href="#nandgame-攻略">NandGame 攻略</a></h1>
<p><a href="https://nandgame.com/">NandGame</a></p>
<ol>
<li>難しいアナログ電気の世界で我慢してなんとか 0, 1 の世界を作る。</li>
<li>小学校の算数より簡単な世界になる。</li>
<li>単純明快な理論をベースにそれまでできなかった速度で大量の計算ができるようになったが、
結局、とてつもなく複雑なハードウェアとソフトウェアの世界が構築された。助けてくれ。</li>
</ol>
<h2 id="and-or-not"><a class="header" href="#and-or-not">AND, OR, NOT</a></h2>
<p>数学や論理学で使われる「かつ」「または」「でない」だが、別にそこまで言わなくても
日常で使う範囲の理解で問題ない。
ただし「かつ」は両方 1 のときも 1 とする。
定義の問題であって数学に合わせたと思っておく。</p>
<p>両方 1 のときに 0 とする「または」を exclusive or (XOR; 排他的論理和) と呼ぶ。
mod 2 (2 で割った余り) の数学を使いたいときはこちらで定義すればよいし、決めの問題。
また、mod 2 とか関係なくてもどうせそのうち欲しくなる。</p>
<p>A AND B (A かつ B)</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>A OR B (A または B)</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>NOT A</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td></tr>
</tbody></table>
</div>
<h2 id="or-を消す-and-を消す"><a class="header" href="#or-を消す-and-を消す">OR を消す (AND を消す)</a></h2>
<p>唐突だがここでド・モルガンの法則を思い出す。</p>
<p>\( \overline{ A + B } = \overline{ A } \cdot \overline{ B } \)</p>
<p>記号の意味を知らずに見るとうわっとなるかもしれないが、</p>
<ul>
<li>上に線を引いたら NOT を表す。</li>
<li>掛け算は AND を表す。</li>
<li>足し算は OR を表す。</li>
</ul>
<p>つまり、<code>NOT (A OR B) = (NOT A) AND (NOT B)</code> という意味である。</p>
<ul>
<li>A または B、ではない</li>
<li>A でない、かつ、B でもない</li>
</ul>
<p>ベン図を書けば一目瞭然だし、そもそも論理式の公式というのは A, B のような変数に
0, 1 しか入らないので全通り代入して一致するか検証するだけで厳密に証明できてしまう。</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>A OR B</th><th>NOT (A OR B)</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>0</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>NOT A</th><th>NOT B</th><th>(NOT A) AND (NOT B)</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>この式をよく見ると、OR を消して AND にできそうな気がしてくる。
少々テクニカルだが、NOT を何とかひねり出したいという発想のもと、
まず、X の否定の否定を考える。
0 は 1 になって 0 になる。1 は 0 になって 1 になる。
そこまで考える必要もなく、当然値は変わらない。</p>
<p>\( X = \overline{ \overline{ X } } \)</p>
<p>A OR B に対してそれを適用する。</p>
<p>\( A + B = \overline{ \overline{ A + B } } \)</p>
<p>これで内側にド・モルガンの法則が使える。</p>
<p>\( A + B = \overline{ \overline{ A } \cdot \overline{ B } } \)</p>
<p>これで AND と NOT だけの式にできた！
ちょっとテクニカルな式変形をした気がするが、ベン図を書いて考えても簡単にできる。</p>
<p>また、ド・モルガンの法則は AND を OR に変えることができるので、
同様の操作で OR と NOT だけの式に変換することもできる。
実は、OR が無くても (AND がなくても)、困らないのである
(めちゃくちゃ読みづらくはなる)。</p>
<h2 id="nand-だけにもできる"><a class="header" href="#nand-だけにもできる">NAND だけにもできる</a></h2>
<p>NAND (なんど) とは NOT AND のことで、<code>A NAND B = NOT (A AND B)</code> である。
実は、これ1つあれば困らないことが示せる。</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>A NAND B</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>0</td></tr>
</tbody></table>
</div>
<p>前節で AND と NOT だけあれば困らないことが分かっているので、
NAND だけを使って AND と NOT を作れないか考えてみる。</p>
<p>まず、<code>NOT A</code> を考える。
入力パラメータの数が違うのがやや気になるが、他にやりようがないので NAND の両辺に
A を渡してみよう。</p>
<p><code>A NAND A</code></p>
<p>NAND の定義の表で <code>A = B</code> である一番上と一番下の行を見ると、
ちょうど NOT になっている。
または、<code>A AND A = A</code> という公式 (証明は A に 0 と 1 を入れてそれぞれ確かめるだけ)</p>
<p><code>A NAND A = NOT (A AND A) = NOT A</code></p>
<p>次に AND を作りたいが、NAND は <code>A AND B</code> の NOT を取ったものだったので、
そこに NOT を被せれば <code>A AND B</code> に戻せる。</p>
<p><code>A AND B = NOT(A NAND B)</code></p>
<p>NOT は既に NAND だけで表せているから、AND も NAND だけで表せることが分かった。</p>
<p>同様の方法で NOR (のあ) だけで AND, OR, NOT すべてを表すこともできる。
以上より、NAND や NOR はそれ1つだけであらゆる論理式を記述することができるという意味で、
<strong>万能ゲート</strong> (universal gate) と呼ばれる。</p>
<h2 id="and-or-not-があればすべての論理を表せる"><a class="header" href="#and-or-not-があればすべての論理を表せる">AND, OR, NOT があればすべての論理を表せる</a></h2>
<p>細かいことを言うと、ここまでで分かったのは NAND (または NOR) は
AND, OR, NOT の組と表現能力が等しいというところまでである。</p>
<ul>
<li>AND, OR, NOT は機械的に NAND のみの式に変換できる。</li>
<li>NAND を機械的に AND, NOT のみの式に変換できる。</li>
</ul>
<p>実は、というほどのことでもないかもしれないが、AND, OR, NOT で
すべての論理を表すことができる。
この3つがあれば、表せないものがあって困るなんてことがないというのは
直感的に明らかかもしれない。
なのでそこから機械的に変換可能な NAND だけですべての論理が記述可能と言えるわけである。</p>
<p>というわけで、本当は AND, OR, NOT だけですべての論理が表せることを
証明しないといけない。
あまりちゃんとやらずに進む資料も多いし別にそれでいいとも思うが、
気になる人向けに一応証明の概略を書いておく。</p>
<h3 id="証明の概略"><a class="header" href="#証明の概略">証明の概略</a></h3>
<p>まず、「すべての論理回路」という言葉が緩すぎてどう扱ったらよいか迷ってしまう。</p>
<p>N 入力 M 出力の論理回路というものを考えてみる。
N=3, M=2 とした場合の表を示す。</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>C</th><th>OUT1</th><th>OUT2</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>?</td><td>?</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>?</td><td>?</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>?</td><td>?</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>?</td><td>?</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>?</td><td>?</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>?</td><td>?</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>?</td><td>?</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>?</td><td>?</td></tr>
</tbody></table>
</div>
<p>? と置いたマスが16個ある。
ここにそれぞれ好きな数 (ただし 0 または 1 に限る) を入れれば
1つの論理回路が完成する。
1行につき 2 bit の出力を決める必要があり、それは他の行からの制約を一切受けない。
なので1行につき出力パターンの組み合わせが \( 2^2 \) 通り、
出力ビット数 M を使って一般に表すと \( 2^M \) 通りある。</p>
<p>そして行数だが、これは入力ビットのパターン数分だけあるので例では \( 2^3 \) 行、
入力ビット数 N を使って一般化すると \( 2^N \) 行となる。</p>
<p>以上より、N 入力 M 出力の論理回路とは、図の ? 部分の埋め方の場合の数通りしかない。
その数は、
\( (2^M)^(2^N) \)
(2のM乗を、(2のN乗)乗したもの) となる。
これは当然 N, M を大きくすると爆発的に大きくはなるが、有限値ではある。</p>
<p>この考え方をもとに、任意の入出力サイズ N, M について AND, OR, NOT
(ここで無理に NAND だけでなんとかしようとする必要はない) だけで
全ての表のパターンを表現できることを示せばよい、という方針が立った。</p>
<p>次に、任意の N, M (1以上の整数) について、という部分が難しいので、
数学的帰納法を使うことを試みる。</p>
<p>(1) N=1, M=1 のとき、回路は以下の4通りしかない。</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>A</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>A</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>A</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>これらすべてを AND, OR, NOT のみで表してみよう。
と言ってもこれは大変簡単で、必要なのは NOT のみである。</p>
<ul>
<li><code>OUT = 0</code></li>
<li><code>OUT = A</code></li>
<li><code>OUT = NOT A</code></li>
<li><code>OUT = 1</code></li>
</ul>
<p>(2) 次に、サイズ (N, M) の論理回路がすべて AND, OR, NOT のみで
構成する方法があると仮定し、
サイズ (N+1, M) の論理回路 (入力ビット数が1増えた) のすべてのパターンを、
存在すると仮定した方法に AND, OR, NOT のみを組み合わせることによって
構成可能なことを示す。</p>
<p>(3) 同様に、(N, M) がすべて構成可能という仮定の下で、(N, M+1) も構成可能であるという
ことを示す。</p>
<p>(1)(2)(3) を組み合わせれば、</p>
<ul>
<li>(1, 1) で成り立つ</li>
<li>(1, 2) で成り立つ</li>
<li>(1, 3) で成り立つ</li>
<li>(2, 3) で成り立つ</li>
<li>...</li>
</ul>
<p>のように、任意の狙った (N, M) について成り立つことが言える。</p>
<h2 id="nandgame-の意図"><a class="header" href="#nandgame-の意図">NandGame の意図</a></h2>
<p>コンピュータの中身は NAND を計算できる素子と、それ同士の配線からのみでできている。
現代の IC (Integrated Circuit), LSI (Large Scale Integrated) は
シリコンをナノメートル単位で加工して、トランジスタで作った NAND ゲートを
億を超えるほどの数を作ってつなげている。</p>
<p>ちなみに全部 NAND なのは数学的にきれいだから、ではなく、作るのが一番簡単だかららしい。</p>
<p>コンピュータがのどこがすごいか、なぜ21世紀が情報化社会と呼ばれているか、
なぜ人類の科学技術を先に進めたか、という理由の本質は、
0, 1 の世界にした直後の話が小学校の算数よりも簡単だから。
大学生にこれを教えていることがばれると示しがつかないので格好をつけるために
難しい話をしようとすればできるが、本質はそこにはない。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="マルチコアと同期"><a class="header" href="#マルチコアと同期">マルチコアと同期</a></h1>
<p>3行まとめ</p>
<ul>
<li>ロックを使え。</li>
</ul>
<h2 id="マルチスレッド"><a class="header" href="#マルチスレッド">マルチスレッド</a></h2>
<p>シングルコアでは物理的に同時に動くのは1つのプログラムである。
しかし、その時代から OS によるマルチタスキング・マルチスレッドの概念はあった。
OS が適当なタイミング (特別な理由がなければタイマ割り込み) を契機に実行中の
スレッドから実行権を剥奪 (プリエンプト) し、別のスレッドに切り替える。</p>
<p>※それより前は OS ではなくアプリケーションが自ら CPU を手放す協調的スケジューリングも
あったが、アプリがバグると CPU を放さなくなってしまうので、現代の OS ではシステムが
勝手に (タイマ割り込みで) タスクを切り替える、
プリエンプティブスケジューリングが採用されることが多い。
ただし OS のスレッドの上でユーザランドでタスクを切り替えるグリーンスレッドだとか
最近流行りの async-await <sup class="footnote-reference"><a href="#1">1</a></sup>: 系の話では協調的スケジューリングも現役と言える。</p>
<p>現代ではシングルコア性能の向上に限界を迎え、CPU のマルチコア化が進んでいる。
ハードウェア設計の方の話で N コア M スレッドのように言われると
コアという用語が何を指すのか分かりづらいため、ソフトウェア/OS の世界では
「CPU0, CPU1, ...」「ハードウェアスレッド」のような呼び方をすることも多い。
物理コア、論理コアという便利な言い回しもある。
しかし口語では簡単にコアと言ってしまうことも多く、要はプログラムを物理的に
同時に実行できる単位1つ分のことである。</p>
<p>マルチコア用 OS では、スレッドを同時にコア数分まで同時に物理的に実行することができる。
しかしそれより多くは不可能なので、そこから先はシングルスレッドと同様の方法で
スレッドの切り替えを行うことになる。</p>
<p>マルチコア環境では複数のプログラムを同時に実行するとマルチコアの恩恵を受けやすいが、
1つのプログラムに関してはマルチスレッドプログラミングを意識して行わないと
マルチコアの恩恵をほとんど受けられない。</p>
<p>PC の CPU 使用率の (できればコアごとの) モニタを見てみると分かるが、
現代の PC においては、一部の限られた作業以外では CPU コアを持て余しているのが
普通である。
シングルコアの時代では割と頻繁に CPU 使用率が 100% に「張り付いていた」が、
現代では全コア 100% となることは一部のタスクを除いてほとんどない。
したがって CPU が実行速度のボトルネックになることは少なく、
高級なコア数の多い CPU を選ぶ価値は低い。</p>
<p>ただしマルチコア CPU の並列性を大いに生かした作業を行う場合は例外であり、
低性能なコア数の少ない CPU を強制的に使用させるような行為は基本的人権の侵害となる。</p>
<ul>
<li>プログラムの並列ビルド</li>
<li>将棋の手読み</li>
<li>AI のための行列演算は GPU を用いた方がよい。</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>共通しているのは見た目や使い勝手のみで、
具体的に何が起こるかはプログラミング言語ごとにバラバラで一概には言い難い。</p>
</div>
<h2 id="主流のハードウェア構成"><a class="header" href="#主流のハードウェア構成">主流のハードウェア構成</a></h2>
<p>主流でなければ色々な構成が考えられるという前提の上で、PC やスマホ等で主流の構成は</p>
<ul>
<li>N コア M スレッド
<ul>
<li>例: 8 コア 16 スレッド</li>
<li>プログラムの実行主体が 1 コアあたり (M/N) 本ある、という意味。</li>
<li>ソフトウェア視点、OS を書くくらいの視点以上からは単に M コアであるとみなして
問題ない。</li>
<li>例: 8 コア 16 スレッド =&gt; OS からは CPU0..15 の 16 コアあるように見えるはず</li>
</ul>
</li>
<li>L1 キャッシュ (コアごと) SRAM</li>
<li>L2 キャッシュ (共通)</li>
<li>L3 キャッシュ (共通)</li>
<li>メモリ DRAM
<ul>
<li>CPU の速度向上に置いて行かれてとんでもなく遅い(だからキャッシュがある)。</li>
</ul>
</li>
</ul>
<h3 id="simultaneous-multi-threading-smt"><a class="header" href="#simultaneous-multi-threading-smt">Simultaneous Multi-Threading (SMT)</a></h3>
<p>N コア M スレッドの補足。
SMT と呼ばれる技術である。
Intel 用語だと Intel Hyper-Threading。</p>
<p>(CPU 設計上の狭い意味で) コアと呼ばれるものの1つ1つの中には、
演算器やメモリの読み書きユニット、L1 キャッシュのような各種ユニットが含まれている。</p>
<p>コアごとに各クロックで、1命令を細かく切り刻んだステージを複数命令分同時に実行していく
(パイプライン実行) のだが、その様子を観察するとハードウェアユニットを各クロックで
100% 使用していないということが分かった
(普通のプログラムを普通に動かして各ユニットが各クロックで 100% フル稼働するとは
考えにくい)。</p>
<p>そこで、あるユニットを使いたいときは隣のスレッドが使い終わるまで待つような調停を
入れつつ、物理コア内で2本のハードウェアスレッドを実行できるようにしたものである。
加算器やメモリロードストアユニットのようなよく使われるものはそれなりに競合するだろうし、
1コアあたり2スレッドとしたところで性能は2倍とはならない。
実際のところ、1.3 倍程度？らしい。</p>
<h2 id="スレッドライブラリ"><a class="header" href="#スレッドライブラリ">スレッドライブラリ</a></h2>
<p>だいたいのところ、関数をスレッド生成関数に渡すとそれを別スレッドとして
実行開始してくれることが多い。
スレッドの起動パラメータを渡せることもあれば、クロージャの環境キャプチャを使えと
言われることも。move セマンティクスに対応していると嬉しい。
ラムダ式があると記述が楽なこともあれば、大きなスレッドは普通に関数として書きたいことも。</p>
<p>join でスレッド終了の待ち合わせと返り値を受け渡せることが多い。
ただし実戦は別スレッドでのエラー (or 例外) 処理とリソースの解放義務が複雑に絡み合い
カオスになりがち。Rust を使おう。</p>
<h3 id="pthread"><a class="header" href="#pthread">pthread</a></h3>
<p>POSIX 標準の C API。</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

void *print_hello(void *arg) {
    printf("Hello, World!\n");
    return NULL;
}

int main() {
    pthread_t thread1;

    if (pthread_create(&amp;thread1, NULL, print_hello, NULL) != 0) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    if (pthread_join(thread1, NULL) != 0) {
        fprintf(stderr, "Error joining thread\n");
        return 1;
    }

    return 0;
}
</code></pre>
<h3 id="stdthread"><a class="header" href="#stdthread">std::thread</a></h3>
<p>余計な記述が少なく結構使いやすい。
スレッド内で発生した例外が join() で受け取れたり、結構頑張っている。</p>
<pre><code class="language-C++">#include &lt;cassert&gt;
#include &lt;thread&gt;

int main()
{
  int x = 0, y = 0;

  std::thread t([&amp;]{ ++x; });
  --y;
  t.join();

  assert(x == 1 &amp;&amp; y == -1);
  return 0;
}
</code></pre>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>スレッドセーフでないコードはコンパイルが通らない。</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<h2 id="競合状態-race-condition"><a class="header" href="#競合状態-race-condition">競合状態 (race condition)</a></h2>
<p>スレッド間で通信をするためには、メモリ空間を共有していることを考えると、
共有メモリを読み書きするのが手軽である。</p>
<p>以下は shared_mem を 256 スレッドから 1000000 回インクリメントするが、
256000000 にはならない (ことがある)。</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

void *proc(void *arg) {
  int *shared_mem = (int *)arg;
  for (int i = 0; i &lt; 1000000; i++) {
    (*shared_mem)++;
  }

  return NULL;
}

int main() {
  pthread_t th[256];
  int shared_mem = 0;

  for (int i = 0; i &lt; 256; i++) {
    if (pthread_create(&amp;th[i], NULL, proc, &amp;shared_mem) != 0) {
      fprintf(stderr, "Error creating thread\n");
      return 1;
    }
  }
  for (int i = 0; i &lt; 256; i++) {
    if (pthread_join(th[i], NULL) != 0) {
      fprintf(stderr, "Error joining thread\n");
      return 1;
    }
  }

  printf("shared_mem = %d\n", shared_mem);

  return 0;
}
</code></pre>
<p>このように何の工夫もなく複数のスレッドから共通のメモリを読み書きすると、色々と壊れる。
しかも確率的にごく稀に壊れることもある。
これを競合状態 (race condition)、スレッドセーフでない等という。</p>
<p>スレッドセーフでないコードが具体的にどうなるかは非常に説明が難しい。
当然ハードウェア実装にもよる。</p>
<p>昔ながらの教科書では以下のように説明されることが多いし、一旦はこれで納得すること。
でも～なケースなら大丈夫じゃないの？と思ったりするかもしれないが、
大抵の場合全然大丈夫じゃないので CPU 内部の挙動を説明できるレベルにない間は
必ずロックを取ること。</p>
<ol>
<li>スレッドAがメモリから値 0 を CPU 内に読む</li>
<li>スレッドBがメモリから値 0 を CPU 内に読む</li>
<li>スレッドAが CPU 内でインクリメントを行い、値 1 を CPU 内に用意する</li>
<li>スレッドAがメモリへ値 1 を書き込む</li>
<li>スレッドBが CPU 内でインクリメントを行い、値 1 を CPU 内に用意する</li>
<li>スレッドBがメモリへ値 1 を書き込む</li>
</ol>
<ul>
<li>まず、コンパイラの最適化がかかる。コンパイラ最適化はシングルスレッドでの実行結果が
変わらないことしか保証しない。
<ul>
<li><code>volatile int *</code> とすると、1000000 回メモリに書き込む機械語が生成されることは
保証される。ただし volatile 単独ではスレッドセーフにはならない。
巷にはインチキコードが溢れているので注意。</li>
</ul>
</li>
<li>高機能なプロセッサでは Out-of-Order 実行によって CPU の内部で機械語の実行順序を
並べ替えられる。こちらもシングルスレッドでの実行結果が変わらないことしか保証しない。
<ul>
<li>こんなとんでもないことをわざわざする理由については、CPU 設計のパイプラインと
命令間依存性、ハザードの話を参照。</li>
</ul>
</li>
<li>パイプライン実行によって1命令を数～数十ステージに分割し、何クロックもかけて、
他の命令と同時並列で実行する。</li>
<li>そのような CPU コアが複数あり、それぞれが同一クロックで独立して動いている。</li>
</ul>
<p>Note: 読み出しのみならセーフ。
メモリに置いた定数を複数スレッドから共有するのは問題ない。</p>
<p>そのままだとレースコンディションを起こしてしまうようなコード区間を
クリティカルセクションという。
クリティカルセクションを保護してスレッドセーフにするために待ち合わせ等を
行うことを同期をとる (synchronize) という。</p>
<h2 id="ロック-ミューテックス-mutex"><a class="header" href="#ロック-ミューテックス-mutex">ロック (ミューテックス, Mutex)</a></h2>
<p>ロックは同時に一人しか獲得する (acquire) ことができない同期プリミティブである。
とりあえずこれを覚えるだけで OK と言っても過言ではない。
クリティカルセクションが終了したら解放する (release)。</p>
<p>ロックが取れない場合、スレッドを sleep 状態
(カーネルのスケジューラによる管理状態の1つ) に入れてアンロックされるまで
スケジュールから外される。
ただしこれはコンテキストスイッチが伴いオーバーヘッドが大きいので、
ロックを持っているスレッドが他のコアにおり、相手がメモリを少しいじって
即アンロックするだけならばそのままビジーループで待った方が効率よい(マルチコアの場合)。
よって一定回数スピン (ビジーループ) して待ち、それでも取れないなら
スリープするという最適化がよく行われる。</p>
<h3 id="ユーザランドスピンロック-上級者向け"><a class="header" href="#ユーザランドスピンロック-上級者向け">ユーザランドスピンロック (上級者向け)</a></h3>
<p>スレッドをスリープに入れるとか、相手がアンロックした時に起きてくるとかは
カーネルランドでしかできないので、mutex lock/unlock には
システムコールを発行する必要がある。</p>
<p>それが嫌な場合、スリープを諦めることを条件に、
スピンロックをユーザランドで実装することは不可能ではない
(スピンロックを作るためのアトミック命令はユーザモードでも実行可能なため)。
ただし、ユーザモードのコードは常にタイマ割り込みによってカーネルにプリエンプトされる
可能性があり、それを防ぐ術もない。
ロックを持ったスレッドが CPU を奪われると、再度 CPU を割り当てられて
アンロックを実行するまで待っているスレッドはビジーループでそのコアを使用率 100% で
使い潰すことになる。
とはいえ、現代の PC/サーバ クラスのマルチコア環境で全コアを使い切っている状況は
ほとんどなく、持て余しているというのも実情である。
なので実行可能 (CPU 割り当て可能) 状態のスレッド数がコア数を上回り続けることは
ほとんどなく、ロックを持ったスレッドが CPU を奪われたままになり続けることは
ほとんどないと言えなくもない。</p>
<p>というわけで私からは評価不能である。
とりあえず、とあるデータベースソフトウェアがそのようなことをやっていて、
Linus からは pure garbage などという暴言を頂いたようだ。</p>
<h3 id="rwlock"><a class="header" href="#rwlock">RwLock</a></h3>
<p>読み出しはよく行われるが、書き換えは稀にしか起こらないようなケースがある。
複数の読み出しはロックなしで同時に行っても安全だが、
書き換え中は他のスレッドの読み出しと書き込み両方を禁止する必要がある。</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Read</th><th>Write</th></tr></thead><tbody>
<tr><td>Read</td><td>OK</td><td>NG</td></tr>
<tr><td>Write</td><td>NG</td><td>NG</td></tr>
</tbody></table>
</div>
<p>いずれか1つが Write アクセスの場合は Mutex と同じだが、
すべて Read アクセスの場合はロックなしの動作になるようなロックがあると効率がよい。
それが Read Write Lock または Exclusive Shared Lock と呼ばれるものである。
ファイルロックも同じような仕組みが提供されることが多い。</p>
<h2 id="条件変数-condition-variable"><a class="header" href="#条件変数-condition-variable">条件変数 (Condition Variable)</a></h2>
<p>ユーザランドで Mutex を使えば、ロックを取れなかったときにスレッドをスリープ状態にして
OS に CPU (コア) を他のスレッドに割り当ててもらって CPU を有効活用できる。
また、スリープ状態のスレッドは実行可能になったら適切に起こす (wake up) 必要がある。</p>
<p>このスリープをもっと汎用的に使えるように設計されたのが、条件変数である。
モニタパターンとも呼ばれる。
ちょっと使い方にクセがあって条件変数という名前も直感的でないが、
非常に汎用性が高く、一度覚えれば CPU を適切に割り当てるプログラムが書けるようになる。
条件変数という名前の由来は私もよく分からないので少なくとも名前の意味を
考えるのはやめておくのをおすすめする。</p>
<p>条件変数は単独で使用するのではなく、他の要素と同時にパターンに従って
使用されることを前提として設計されている。</p>
<ul>
<li>Mutex またはそれに類するロック</li>
<li>その Mutex で保護された変数群</li>
<li>その Mutex に関連付けられた条件変数とモニタ条件</li>
</ul>
<p>使い方は決まっているのでまずは使い方を丸覚えしたほうがよい。</p>
<pre><code class="language-C">// mutex = init_mutex();
// condvar = init_condvar(mutex);
mutex.lock();
while (!(condition)) {
  // unlock and sleep
  condvar.wait();
  // wakeup and lock
}
do_something1();
mutex.unlock();
</code></pre>
<ol>
<li>まず、とにもかくにもロックを取得し、クリティカルセクションに入る。</li>
<li>この時点で共有変数には自分一人しかアクセスできないことが保証されている。
ロックで保護された変数を読み取り、「条件」が満たされていないならば
その条件に対応させる「条件変数上で待機する (wait)」。
ここで、if 文ではなく while 文としておく。
理由は後述するが、最初は定型文として覚えてしまった方がよい。</li>
<li>wait は <strong>ロックを外し</strong>、このスレッドをスリープさせる。
対象の条件変数のモニタに入る、とも言う。</li>
<li>wait は 対象の条件変数に対して通知 (notify, signal, wakeup などと言われる)
が来ると起きる。これについては後述。
また、<strong>ロックを再度取得した状態で</strong> 起きてくる(そういう風に頑張って作られている)。</li>
<li>起床後、もう一度同じ条件を確認する。ロックを持った状態で起きてくるので安全である。
条件が満たされているのを確認できた場合はループを抜けて本処理に入る。
条件が満たされていない場合は前回と同様にもう一度 wait する。</li>
<li>満たされた条件のもと何らかの処理を行い、アンロックし、完了。</li>
</ol>
<p>while ループとしておき起床後に再度同じ条件をチェックする理由は</p>
<ul>
<li>spurious wakeup といって、起こされていないのに起きる可能性がある。
<ul>
<li>ほとんどのユーザランドライブラリで注意されている。</li>
</ul>
</li>
<li>他にも同じ条件変数で寝ているスレッドがあり、ロックを取りながら起きようとする際に
他のスレッドに負け、勝ったスレッドがロック状態のうちに条件を満たさないように
保護された変数を変更した場合、ロックを取れた頃には条件が満たされない状態に
なってしまっている。</li>
</ul>
<p>前者はユーザランドでどんな状況でも厳密に正しく実装するのが重すぎるから、らしいが
具体的なところはよくわからない。
シグナルによる EINTR のハンドリングが絡むとよくないとの噂がある。
Linux や FreeBSD のカーネル用関数では spurious wakeup は触れられておらず、
起きないのかもしれない。
しかし後者の問題は常に対応する必要があり、後者を対応すれば自然に前者にも
対応できるのだから、結論は簡単で常に while のロジックを使うべきである。</p>
<p>プログラミング言語やライブラリによっては <code>while (!(condition))</code> の condition の
部分をラムダ式等で渡せる (渡すしかない) ようになっているものもある。</p>
<ul>
<li>while を使わない等の間違った使い方を封殺する。</li>
<li>while の中に成立を待つ条件の否定を書かないといけないのを、
関数から肯定の条件を返すようにできる。</li>
</ul>
<pre><code class="language-C">// mutex = init_mutex();
// condvar = init_condvar(mutex);
mutex.lock();
do_something2();
if (condition) {
  condvar.notify_all();
}
mutex.unlock();
</code></pre>
<ol>
<li>起こす側も、まずロックは取得する。
起こす側と起こされる側を同一ロジックにすることも可能だが、使い方を理解すれば
自然にそのようにも書けるようになる。</li>
<li>ロックで保護された変数を操作し、もし条件が満たされるようになり
条件が満たされず寝ているスレッドがいるなら起こす必要がある場合、
notify 操作を行う。
notify_one, notify_all (wakeup_one, wakeup_all) のように複数の機能が提供
されている場合があるが、よほど自信がある場合以外は notify_all を強くおすすめする。</li>
<li>アンロックして完了。</li>
</ol>
<h2 id="注意-volatile-は罠"><a class="header" href="#注意-volatile-は罠">注意: volatile は罠</a></h2>
<p>CON02-C. volatile を同期用プリミティブとして使用しない</p>
<p><a href="https://www.jpcert.or.jp/sc-rules/c-con02-c.html">https://www.jpcert.or.jp/sc-rules/c-con02-c.html</a></p>
<p>volatile は主にメモリマップされたハードウェアレジスタを読み書きすることを
意図したもので、単体でスレッドセーフにする効果はない。
メモリアクセスをコンパイラ最適化で省略しないというのは共有メモリで通信する以上
必須ではあるのだが、それだけでは全然足りないためである。
生成される機械語が変わるので、レースバグの再現率を変える実験くらいにしか使えない。
レースバグは絶対に直らない。</p>
<ul>
<li>volatile オブジェクトへの読み書きのメモリアクセスは省略されない。
<ul>
<li>Memory Mapped I/O (メモリアクセス命令で特定レンジへのアクセスが
メインメモリではなく他のハードウェアデバイスへ飛んで制御できる方法。)
がうまくいくようになる。</li>
<li>2回異なるデータを同じ場所に書き込んだ時、1回目は無駄だからといって
省略してはならない。それは通常のメモリの場合であって、それ以外の
ハードウェアデバイスへの書き込みには意味がある可能性がある。
1を書き込んだタイミングで処理開始、とか。</li>
<li>複数回の同一アドレスからの読み出しも省略してはならない。
CPU 外のハードウェアは CPU とは独立して動作しており、
読み出される値は変更される可能性がある
(volatile = 揮発性 = 何もしなくても状態が勝手に変わる)。</li>
</ul>
</li>
<li>メモリを使わずレジスタだけで済ませるという最適化も無効。</li>
</ul>
<p>難しい話が分からない場合は、書き込みを伴う共有変数には必ずロックを使うこと。
ロックに代表される同期プリミティブと呼ばれるオブジェクトは、
難しい話を全てクリアしてある。</p>
<h2 id="アトミック命令-ここから上級者向け"><a class="header" href="#アトミック命令-ここから上級者向け">アトミック命令 (ここから上級者向け)</a></h2>
<p>古い OS の教科書にはピーターソンのアルゴリズムやデッカーのアルゴリズムなど、
ハードウェアサポートなしで同期を取ろうとする天才プログラムが載っていたりするが、
Out-of-Order + マルチコアのような現代の世紀末環境では全く通用しないし、
専用の命令をハードウェアに用意してもらった方が効率的で使い方も簡単である。</p>
<p>アトミック性 (atomicity) とは、不可分性と訳され、他の実行コンテキストから
その命令の実行前と実行後のどちらかの状態しか観測されないという性質のことである。
逆に言うとアトミックと明示的に言われない限りは保証されないと思っておいた方がよい。</p>
<p>アトミック性の概念自体は CPU の提供するアトミック命令だけではなく、
もっと広く用いられるものである。
例えばロックを取っている間に複数の変数を変更した場合、同じくロックを取ってアクセスする
他のスレッドからは、ロックを取る前かロックを解除した後の状態しか観測されない。</p>
<p>実際のところ、メモリアラインされた 32 bit ロード or ストアは
何もしなくてもアトミックになることが多い。
明示的にアトミック命令と言われた場合、read-modify-write (atomic-add, atomic-swap)
を指すことが多い。
メモリを読んで、それに何か計算をして、結果を書き込む、という操作は
典型的なレースコンディションを引き起こす操作だが、
現代の CPU ではそれくらいなら専用命令を呼ぶだけでアトミックに
処理できるということである。
アトミック命令は内部的にはバスロック (ハードウェア論理レベルでメモリバスを占有する) で
実装されることが多い、気がする。多分。</p>
<p>(アトミック命令で実装されている) ロックを使わずアトミック命令を直接呼ぶだけで
実現可能な単純なロジックならば、アトミック命令で実装した方が性能は上がる可能性が高い。
外部からのキャンセルリクエストのようなものならば atomic bool 等で十分かもしれない。
ただしスレッドセーフにしなければならないデータ構造が変数2つ以上になった瞬間
ロックで書き直さなければならなくなったりもする。
可読性やメンテナンス性とのトレードオフとなるのでよく考えること。</p>
<h2 id="メモリオーダリングメモリバリアフェンス"><a class="header" href="#メモリオーダリングメモリバリアフェンス">メモリオーダリング・メモリバリア・フェンス</a></h2>
<p>アトミック性自体はアトミック命令を呼べば実現するが、
アトミック性だけで十分なケースは大して多くない。</p>
<p>あるスレッドがメモリを書き換えたとき、その書き換えの順番が他のスレッドから
同じ順番で見えるとは保証されないことがあるからである。
コンパイラ最適化による命令の並べ替えもその一種と言えなくもないが、
こちらは volatile で制御できなくもない。
問題は CPU のアウトオブオーダ実行による CPU 内部での命令の並べ替えである。</p>
<p>現代の性能重視の CPU は、シングルスレッドで考えた実行結果が変わらないという制約の下で、
命令の実行順を入れ替えることがある。
これは現代 CPU の中でも最も複雑な部分と思われる。
アウトオブオーダ機能の自作はおすすめしないしデバッグも困難を極める。
なぜわざわざそんなことをするかというと、そうした方が速いケースがあるからである。
命令の (パイプライン化され細かく分かれたステージのうちの) 実行には入力オペランド
(例えば、足し算なら、その対象の2つのレジスタなど) が確定している必要があるが、
そのレジスタが直前の命令によって書き込まれる</p>
<h2 id="メモリモデル一貫性モデル"><a class="header" href="#メモリモデル一貫性モデル">メモリモデル・一貫性モデル</a></h2>
<h2 id="ロックの作り方"><a class="header" href="#ロックの作り方">ロックの作り方</a></h2>
<h3 id="割り込み禁止-シングルコア専用カーネルモード専用"><a class="header" href="#割り込み禁止-シングルコア専用カーネルモード専用">割り込み禁止 (シングルコア専用・カーネルモード専用)</a></h3>
<p>シングルコア限定で絶対にレースしない必殺技があって、それが割り込み禁止である。</p>
<p>CPU の割り込み機能はオフにできるため、そうしている間は突然実行コンテキストが切り替わる
ことが絶対にない (NMI (Non-Maskable Interrupt) は除く)。
タイマ割り込みも無効になる。</p>
<p>ただし当然、早急な処理を求められる外部ハードウェアへの応答が遅れるため、
長時間のロックはご法度である。
またこれも当然、カーネルモード (OS の中) でしか変更できない。</p>
<p>割り込みハンドラとの間でも同期が取れることになるが、
割り込みハンドラと変数を共有していない場合はプリエンプト禁止で十分かもしれない。
プリエンプト禁止は CPU のハードウェア設定ではなく、OS 上でのソフトウェア的な
制御になる。</p>
<h3 id="スピンロック-マルチコア向けカーネルモード向け"><a class="header" href="#スピンロック-マルチコア向けカーネルモード向け">スピンロック (マルチコア向け・カーネルモード向け)</a></h3>
<p>アトミック命令を使って初めに作ることになる、最も単純なロックである。
シングルコアではビジーウェイト (メモリの値が変わるまで読み続ける) は
他のスレッドにスイッチしてメモリが書き換えられるまで無駄に CPU 時間を消費するため
行儀の悪いスタイルと言われるが、マルチコアではビジーウェイト中も他のコアが動けるため、
ロック時間が十分短いならばコンテキストスイッチのコストがかからずむしろ
性能のよいロックとなる。
また、割り込みハンドラ同士または割り込みハンドラとスレッドコンテキストとの間の
ロックとしても使用可能である。</p>
<p>データ構造としては、ロック本体はメモリ上に 1 word 程度の整数を用意するだけで
ロック1つを実現できる。</p>
<p>xv6 (RISC-V) での実装</p>
<pre><code class="language-C">// Mutual exclusion lock.
struct spinlock {
  uint locked;       // Is the lock held?

  // For debugging:
  char *name;        // Name of lock.
  struct cpu *cpu;   // The cpu holding the lock.
};
</code></pre>
<p>スピンロックを取得した状態で解放前に自身のコアで割り込みが入り、
その割り込みハンドラで同じロックを取得しようとした場合、デッドロックして
コアが割り込みハンドラ内で固まってしまう。
そのため初めにローカルコア割り込みを OFF にしている。
割り込みハンドラからロックしないならば、これは不要とも言える。
ただしタイマ割り込みからのプリエンプトは禁止すべきだろう。
オープンソースの OS の実装を見て回るのもよい。</p>
<p>次の <code>__sync_lock_test_and_set()</code> がアトミック命令で、ロックの本体である。
アセンブラで直接書くか、このように gcc 拡張を使って多少ハードウェア非依存っぽく
書くこともできる。
このようなコンパイラ拡張は、コンパイラへの命令並べ替え禁止効果を含んでいて便利である。
自力でやるときは <code>asm volatile</code> と <code>memory</code> 指定を使う。</p>
<p><code>test_and_set</code> は名前と違って atomic_swap に近いらしい。
「メモリを読んで返す」のと「メモリに第二引数 (1) を書き込む」を同時に行い、
その途中状態を他のコアから観測されないようにする。
具体的にはメモリバスロックを行い、自分以外のコアのメモリアクセスを禁止するとか。多分。</p>
<p>コードとしてはメモリ内容と 1 をアトミックに交換し、0 が取得された場合は
ロックが取れた (ロック変数を0から1に変更した) とみなし、
1 が取得された場合はロックが取れなかった (ロック変数は1から1のまま) とみなす、
というだけのことである。
ロックのキモはたったこれだけではある。
両方のスレッドからアクセス可能な 1 word 程度のメモリがあれば実現できる。
ただし、現代の CPU では考慮すべき事項が多い。</p>
<pre><code class="language-C">// Acquire the lock.
// Loops (spins) until the lock is acquired.
void
acquire(struct spinlock *lk)
{
  push_off(); // disable interrupts to avoid deadlock.
  if(holding(lk))
    panic("acquire");

  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
  //   a5 = 1
  //   s1 = &amp;lk-&gt;locked
  //   amoswap.w.aq a5, a5, (s1)
  while(__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)
    ;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that the critical section's memory
  // references happen strictly after the lock is acquired.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Record info about lock acquisition for holding() and debugging.
  lk-&gt;cpu = mycpu();
}

// Release the lock.
void
release(struct spinlock *lk)
{
  if(!holding(lk))
    panic("release");

  lk-&gt;cpu = 0;

  // Tell the C compiler and the CPU to not move loads or stores
  // past this point, to ensure that all the stores in the critical
  // section are visible to other CPUs before the lock is released,
  // and that loads in the critical section occur strictly before
  // the lock is released.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Release the lock, equivalent to lk-&gt;locked = 0.
  // This code doesn't use a C assignment, since the C standard
  // implies that an assignment might be implemented with
  // multiple store instructions.
  // On RISC-V, sync_lock_release turns into an atomic swap:
  //   s1 = &amp;lk-&gt;locked
  //   amoswap.w zero, zero, (s1)
  __sync_lock_release(&amp;lk-&gt;locked);

  pop_off();
}
</code></pre>
<p>ロックを使わずアトミック命令でスレッドセーフに書く (ロック自体を作る時など)
ための条件は以下の通り。</p>
<ul>
<li>通常のメモリロードストア命令ではなくアトミック命令を使い、
途中の状態を他のコアから観測されないようにする。</li>
<li>コンパイラ最適化を無効にし、特定の行をまたいだ命令の並べ替えを防止する。</li>
<li>メモリバリア命令を置き、それをまたいだ CPU 内での命令の並べ替えを防止する。</li>
</ul>
<p>volatile の付与だけでは全然足りないことが分かる。
通常のロードストア命令は自然にアトミックになる CPU も多いが。</p>
<p>コンパイラによるコンパイル時の並べ替えと CPU による実行時の並べ替えは、
いつやるかが違うだけで概念としては同じものが使える。
メモリの読み書きの (物理的な) 順番の制御をメモリオーダリングと呼び、
手動でそれを防ぐ手段をメモリバリアと呼ぶ。</p>
<p>ちなみに x86 はメモリオーダリングに関してはかなり「堅い」方で、ARM や RISC-V は
「ゆるゆる」である。
Google が Android のために JVM を x86 から ARM に持っていったら
怪奇現象にしか見えないメモリオーダリングのバグに苦労したらしい…。</p>
<h3 id="スリープロック-普通のロック"><a class="header" href="#スリープロック-普通のロック">スリープロック (普通のロック)</a></h3>
<h2 id="ロックフリーアルゴリズム-初心者お断り"><a class="header" href="#ロックフリーアルゴリズム-初心者お断り">ロックフリーアルゴリズム (初心者お断り)</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h1>
<ul>
<li>最初から順に読み進めて読破が狙えるものと、それは普通に無理なものが存在する。</li>
</ul>
<h2 id="データ構造とアルゴリズム"><a class="header" href="#データ構造とアルゴリズム">データ構造とアルゴリズム</a></h2>
<ul>
<li>アルゴリズムイントロダクション
<ul>
<li>Introduction to Algorithms: アルゴリズム入門 (MIT 基準)</li>
<li>アルゴリズム専門の研究者になるなら入門だから…。</li>
<li>数学的厳密性が重視されており、ややマイナーなアルゴリズムも掲載。
その代わり圧倒的な分量を持つ。</li>
</ul>
</li>
<li>もう1冊軽いものがあるとよいと思うが、色々ありすぎて何がよさそうか謎。。</li>
</ul>
<h2 id="形式言語理論"><a class="header" href="#形式言語理論">形式言語理論</a></h2>
<ul>
<li>オートマトン言語理論 計算論</li>
</ul>
<h2 id="オペレーティングシステム"><a class="header" href="#オペレーティングシステム">オペレーティングシステム</a></h2>
<p>cf. コンピュータアーキテクチャ</p>
<ul>
<li>
<p>Operating System Concepts</p>
<ul>
<li>恐竜本。</li>
<li>他にもいくつか案はあるが、多少の実践に立ち入った本よりは下記をやった方がよいのかも。</li>
</ul>
</li>
<li>
<p>6.1810: Operating System Engineering</p>
<ul>
<li>MIT の OS 実践授業</li>
<li>xv6 (最初期の UNIX の ANSI C 再実装) を使う。ソースがコンパクトで綺麗で明快だが
OS のエッセンスは揃っている。</li>
<li>GitHub の risc-v 版ソースコードを手元に用意しながら授業ページの pdf を読めば
あっという間に一流の人形遣いになれそう。</li>
<li>アセンブラ、リンカスクリプト、スタートアップルーチン</li>
<li>昔は x86 だったので、苦行を積みたい場合はそちら。</li>
</ul>
</li>
<li>
<p>30日でできる! OS自作入門</p>
</li>
<li>
<p>ゼロからのOS自作入門</p>
<ul>
<li>BIOS or UEFI およびク〇すぎる x86 のブートアップに正面から向き合うことができる。</li>
<li>理論的な面は弱め。他にないタイプの本であることに間違いはない。</li>
</ul>
</li>
</ul>
<h2 id="コンピュータアーキテクチャ"><a class="header" href="#コンピュータアーキテクチャ">コンピュータアーキテクチャ</a></h2>
<p>cf. ディジタル回路、オペレーティングシステム</p>
<ul>
<li>
<p>コンピュータの構成と設計</p>
<ul>
<li>パタヘネ。これは文句なくまずはこの一冊(日本語版は一冊ではない)でOK。</li>
<li>Amazon 検索だと誤って古い版を買ってしまいやすいので注意(一敗)。</li>
</ul>
</li>
<li>
<p>コンピュータアーキテクチャ 定量的アプローチ</p>
<ul>
<li>ヘネパタ。むずかしい。</li>
</ul>
</li>
<li>
<p>CPU の創りかた</p>
<ul>
<li>20年経っても色あせない名著</li>
<li><del>読んだことがない</del></li>
</ul>
</li>
</ul>
<h2 id="コンパイラ"><a class="header" href="#コンパイラ">コンパイラ</a></h2>
<p>cf. オートマトン、正規表現</p>
<ul>
<li>コンパイラ―原理・技法・ツール
<ul>
<li>ドラゴンブック。</li>
<li>教科書として使うのは微妙な気もするけどだったら何がいいのかはよくわからない。</li>
</ul>
</li>
<li>低レイヤを知りたい人のためのCコンパイラ作成入門 <a href="https://www.sigbus.info/compilerbook">https://www.sigbus.info/compilerbook</a>
<ul>
<li>C で C コンパイラを作る完全実践型。C セルフホスト RTA が流行っているらしい(???)</li>
<li>コンパイラについては構文解析は理論的な面が大きいが、
出力にアセンブラや機械語のローレイヤの知識が必要なのがアレ。</li>
</ul>
</li>
</ul>
<h2 id="データベース"><a class="header" href="#データベース">データベース</a></h2>
<p>わかんない。。</p>
<h2 id="プログラミング"><a class="header" href="#プログラミング">プログラミング</a></h2>
<ul>
<li>コンパイラ言語</li>
<li>スクリプト言語</li>
<li>関数型言語</li>
</ul>
<p>を最低1つずつ習得するのがよいとされている(要出典)。</p>
<h2 id="関数型言語-という訳ではない"><a class="header" href="#関数型言語-という訳ではない">関数型言語 (という訳ではない)</a></h2>
<ul>
<li>SICP
<ul>
<li>最近はやめてしまったらしい。何で LISP を学んだらいいのかわからない。</li>
</ul>
</li>
<li>型システム入門 −プログラミング言語と型の理論− (TAPL)
<ul>
<li>これも関数型言語の本ではないが</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
