<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3日ではなれないかもしれない人形遣い</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">3日ではなれないかもしれない人形遣い</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="nandgame-攻略"><a class="header" href="#nandgame-攻略">NandGame 攻略</a></h1>
<p><a href="https://nandgame.com/">NandGame</a></p>
<ol>
<li>難しいアナログ電気の世界で我慢してなんとか 0, 1 の世界を作る。</li>
<li>小学校の算数より簡単な世界になる。</li>
<li>単純明快な理論をベースにそれまでできなかった速度で大量の計算ができるようになったが、
結局、とてつもなく複雑なハードウェアとソフトウェアの世界が構築された。助けてくれ。</li>
</ol>
<h2 id="and-or-not"><a class="header" href="#and-or-not">AND, OR, NOT</a></h2>
<p>数学や論理学で使われる「かつ」「または」「でない」だが、別にそこまで言わなくても
日常で使う範囲の理解で問題ない。
ただし「かつ」は両方 1 のときも 1 とする。
定義の問題であって数学に合わせたと思っておく。</p>
<p>両方 1 のときに 0 とする「または」を exclusive or (XOR; 排他的論理和) と呼ぶ。
mod 2 (2 で割った余り) の数学を使いたいときはこちらで定義すればよいし、決めの問題。
また、mod 2 とか関係なくてもどうせそのうち欲しくなる。</p>
<p>A AND B (A かつ B)</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>A OR B (A または B)</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>NOT A</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td></tr>
</tbody></table>
</div>
<h2 id="or-を消す-and-を消す"><a class="header" href="#or-を消す-and-を消す">OR を消す (AND を消す)</a></h2>
<p>唐突だがここでド・モルガンの法則を思い出す。</p>
<p>\( \overline{ A + B } = \overline{ A } \cdot \overline{ B } \)</p>
<p>記号の意味を知らずに見るとうわっとなるかもしれないが、</p>
<ul>
<li>上に線を引いたら NOT を表す。</li>
<li>掛け算は AND を表す。</li>
<li>足し算は OR を表す。</li>
</ul>
<p>つまり、<code>NOT (A OR B) = (NOT A) AND (NOT B)</code> という意味である。</p>
<ul>
<li>A または B、ではない</li>
<li>A でない、かつ、B でもない</li>
</ul>
<p>ベン図を書けば一目瞭然だし、そもそも論理式の公式というのは A, B のような変数に
0, 1 しか入らないので全通り代入して一致するか検証するだけで厳密に証明できてしまう。</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>A OR B</th><th>NOT (A OR B)</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>0</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>NOT A</th><th>NOT B</th><th>(NOT A) AND (NOT B)</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>この式をよく見ると、OR を消して AND にできそうな気がしてくる。
少々テクニカルだが、NOT を何とかひねり出したいという発想のもと、
まず、X の否定の否定を考える。
0 は 1 になって 0 になる。1 は 0 になって 1 になる。
そこまで考える必要もなく、当然値は変わらない。</p>
<p>\( X = \overline{ \overline{ X } } \)</p>
<p>A OR B に対してそれを適用する。</p>
<p>\( A + B = \overline{ \overline{ A + B } } \)</p>
<p>これで内側にド・モルガンの法則が使える。</p>
<p>\( A + B = \overline{ \overline{ A } \cdot \overline{ B } } \)</p>
<p>これで AND と NOT だけの式にできた！
ちょっとテクニカルな式変形をした気がするが、ベン図を書いて考えても簡単にできる。</p>
<p>また、ド・モルガンの法則は AND を OR に変えることができるので、
同様の操作で OR と NOT だけの式に変換することもできる。
実は、OR が無くても (AND がなくても)、困らないのである
(めちゃくちゃ読みづらくはなる)。</p>
<h2 id="nand-だけにもできる"><a class="header" href="#nand-だけにもできる">NAND だけにもできる</a></h2>
<p>NAND (なんど) とは NOT AND のことで、<code>A NAND B = NOT (A AND B)</code> である。
実は、これ1つあれば困らないことが示せる。</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>A NAND B</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>0</td></tr>
</tbody></table>
</div>
<p>前節で AND と NOT だけあれば困らないことが分かっているので、
NAND だけを使って AND と NOT を作れないか考えてみる。</p>
<p>まず、<code>NOT A</code> を考える。
入力パラメータの数が違うのがやや気になるが、他にやりようがないので NAND の両辺に
A を渡してみよう。</p>
<p><code>A NAND A</code></p>
<p>NAND の定義の表で <code>A = B</code> である一番上と一番下の行を見ると、
ちょうど NOT になっている。
または、<code>A AND A = A</code> という公式 (証明は A に 0 と 1 を入れてそれぞれ確かめるだけ)</p>
<p><code>A NAND A = NOT (A AND A) = NOT A</code></p>
<p>次に AND を作りたいが、NAND は <code>A AND B</code> の NOT を取ったものだったので、
そこに NOT を被せれば <code>A AND B</code> に戻せる。</p>
<p><code>A AND B = NOT(A NAND B)</code></p>
<p>NOT は既に NAND だけで表せているから、AND も NAND だけで表せることが分かった。</p>
<p>同様の方法で NOR (のあ) だけで AND, OR, NOT すべてを表すこともできる。
以上より、NAND や NOR はそれ1つだけであらゆる論理式を記述することができるという意味で、
<strong>万能ゲート</strong> (universal gate) と呼ばれる。</p>
<h2 id="and-or-not-があればすべての論理を表せる"><a class="header" href="#and-or-not-があればすべての論理を表せる">AND, OR, NOT があればすべての論理を表せる</a></h2>
<p>細かいことを言うと、ここまでで分かったのは NAND (または NOR) は
AND, OR, NOT の組と表現能力が等しいというところまでである。</p>
<ul>
<li>AND, OR, NOT は機械的に NAND のみの式に変換できる。</li>
<li>NAND を機械的に AND, NOT のみの式に変換できる。</li>
</ul>
<p>実は、というほどのことでもないかもしれないが、AND, OR, NOT で
すべての論理を表すことができる。
この3つがあれば、表せないものがあって困るなんてことがないというのは
直感的に明らかかもしれない。
なのでそこから機械的に変換可能な NAND だけですべての論理が記述可能と言えるわけである。</p>
<p>というわけで、本当は AND, OR, NOT だけですべての論理が表せることを
証明しないといけない。
あまりちゃんとやらずに進む資料も多いし別にそれでいいとも思うが、
気になる人向けに一応証明の概略を書いておく。</p>
<h3 id="証明の概略"><a class="header" href="#証明の概略">証明の概略</a></h3>
<p>まず、「すべての論理回路」という言葉が緩すぎてどう扱ったらよいか迷ってしまう。</p>
<p>N 入力 M 出力の論理回路というものを考えてみる。
N=3, M=2 とした場合の表を示す。</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>C</th><th>OUT1</th><th>OUT2</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>?</td><td>?</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>?</td><td>?</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>?</td><td>?</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>?</td><td>?</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>?</td><td>?</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>?</td><td>?</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>?</td><td>?</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>?</td><td>?</td></tr>
</tbody></table>
</div>
<p>? と置いたマスが16個ある。
ここにそれぞれ好きな数 (ただし 0 または 1 に限る) を入れれば
1つの論理回路が完成する。
1行につき 2 bit の出力を決める必要があり、それは他の行からの制約を一切受けない。
なので1行につき出力パターンの組み合わせが \( 2^2 \) 通り、
出力ビット数 M を使って一般に表すと \( 2^M \) 通りある。</p>
<p>そして行数だが、これは入力ビットのパターン数分だけあるので例では \( 2^3 \) 行、
入力ビット数 N を使って一般化すると \( 2^N \) 行となる。</p>
<p>以上より、N 入力 M 出力の論理回路とは、図の ? 部分の埋め方の場合の数通りしかない。
その数は、
\( (2^M)^(2^N) \)
(2のM乗を、(2のN乗)乗したもの) となる。
これは当然 N, M を大きくすると爆発的に大きくはなるが、有限値ではある。</p>
<p>この考え方をもとに、任意の入出力サイズ N, M について AND, OR, NOT
(ここで無理に NAND だけでなんとかしようとする必要はない) だけで
全ての表のパターンを表現できることを示せばよい、という方針が立った。</p>
<p>次に、任意の N, M (1以上の整数) について、という部分が難しいので、
数学的帰納法を使うことを試みる。</p>
<p>(1) N=1, M=1 のとき、回路は以下の4通りしかない。</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>A</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>A</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>A</th><th>OUT</th></tr></thead><tbody>
<tr><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>これらすべてを AND, OR, NOT のみで表してみよう。
と言ってもこれは大変簡単で、必要なのは NOT のみである。</p>
<ul>
<li><code>OUT = 0</code></li>
<li><code>OUT = A</code></li>
<li><code>OUT = NOT A</code></li>
<li><code>OUT = 1</code></li>
</ul>
<p>(2) 次に、サイズ (N, M) の論理回路がすべて AND, OR, NOT のみで
構成する方法があると仮定し、
サイズ (N+1, M) の論理回路 (入力ビット数が1増えた) のすべてのパターンを、
存在すると仮定した方法に AND, OR, NOT のみを組み合わせることによって
構成可能なことを示す。</p>
<p>(3) 同様に、(N, M) がすべて構成可能という仮定の下で、(N, M+1) も構成可能であるという
ことを示す。</p>
<p>(1)(2)(3) を組み合わせれば、</p>
<ul>
<li>(1, 1) で成り立つ</li>
<li>(1, 2) で成り立つ</li>
<li>(1, 3) で成り立つ</li>
<li>(2, 3) で成り立つ</li>
<li>...</li>
</ul>
<p>のように、任意の狙った (N, M) について成り立つことが言える。</p>
<h2 id="nandgame-の意図"><a class="header" href="#nandgame-の意図">NandGame の意図</a></h2>
<p>コンピュータの中身は NAND を計算できる素子と、それ同士の配線からのみでできている。
現代の IC (Integrated Circuit), LSI (Large Scale Integrated) は
シリコンをナノメートル単位で加工して、トランジスタで作った NAND ゲートを
億を超えるほどの数を作ってつなげている。</p>
<p>ちなみに全部 NAND なのは数学的にきれいだから、ではなく、作るのが一番簡単だかららしい。</p>
<p>コンピュータがのどこがすごいか、なぜ21世紀が情報化社会と呼ばれているか、
なぜ人類の科学技術を先に進めたか、という理由の本質は、
0, 1 の世界にした直後の話が小学校の算数よりも簡単だから。
大学生にこれを教えていることがばれると示しがつかないので格好をつけるために
難しい話をしようとすればできるが、本質はそこにはない。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="マルチコアと同期"><a class="header" href="#マルチコアと同期">マルチコアと同期</a></h1>
<p>3行まとめ</p>
<ul>
<li>ロックを使え。</li>
</ul>
<h2 id="マルチスレッド"><a class="header" href="#マルチスレッド">マルチスレッド</a></h2>
<p>シングルコアでは物理的に同時に動くのは1つのプログラムである。
しかし、その時代から OS によるマルチタスキング・マルチスレッドの概念はあった。
OS が適当なタイミング (特別な理由がなければタイマ割り込み) を契機に実行中の
スレッドから実行権を剥奪 (プリエンプト) し、別のスレッドに切り替える。</p>
<p>※それより前は OS ではなくアプリケーションが自ら CPU を手放す協調的スケジューリングも
あったが、アプリがバグると CPU を放さなくなってしまうので、現代の OS ではシステムが
勝手に (タイマ割り込みで) タスクを切り替える、
プリエンプティブスケジューリングが採用されることが多い。
ただし OS のスレッドの上でユーザランドでタスクを切り替えるグリーンスレッドだとか
最近流行りの async-await <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>: 系の話では協調的スケジューリングも現役と言える。</p>
<p>現代ではシングルコア性能の向上に限界を迎え、CPU のマルチコア化が進んでいる。
ハードウェア設計の方の話で N コア M スレッドのように言われると
コアという用語が何を指すのか分かりづらいため、ソフトウェア/OS の世界では
「CPU0, CPU1, ...」「ハードウェアスレッド」のような呼び方をすることも多い。
物理コア、論理コアという便利な言い回しもある。
しかし口語では簡単にコアと言ってしまうことも多く、要はプログラムを物理的に
同時に実行できる単位1つ分のことである。</p>
<p>マルチコア用 OS では、スレッドを同時にコア数分まで同時に物理的に実行することができる。
しかしそれより多くは不可能なので、そこから先はシングルスレッドと同様の方法で
スレッドの切り替えを行うことになる。</p>
<p>マルチコア環境では複数のプログラムを同時に実行するとマルチコアの恩恵を受けやすいが、
1つのプログラムに関してはマルチスレッドプログラミングを意識して行わないと
マルチコアの恩恵をほとんど受けられない。</p>
<p>PC の CPU 使用率の (できればコアごとの) モニタを見てみると分かるが、
現代の PC においては、一部の限られた作業以外では CPU コアを持て余しているのが
普通である。
シングルコアの時代では割と頻繁に CPU 使用率が 100% に「張り付いていた」が、
現代では全コア 100% となることは一部のタスクを除いてほとんどない。
したがって CPU が実行速度のボトルネックになることは少なく、
高級なコア数の多い CPU を選ぶ価値は低い。</p>
<p>ただしマルチコア CPU の並列性を大いに生かした作業を行う場合は例外であり、
低性能なコア数の少ない CPU を強制的に使用させるような行為は基本的人権の侵害となる。</p>
<ul>
<li>プログラムの並列ビルド</li>
<li>将棋の手読み</li>
<li>AI のための行列演算は GPU を用いた方がよい。</li>
</ul>
<h2 id="主流のハードウェア構成"><a class="header" href="#主流のハードウェア構成">主流のハードウェア構成</a></h2>
<p>主流でなければ色々な構成が考えられるという前提の上で、PC やスマホ等で主流の構成は</p>
<ul>
<li>N コア M スレッド
<ul>
<li>例: 8 コア 16 スレッド</li>
<li>プログラムの実行主体が 1 コアあたり (M/N) 本ある、という意味。</li>
<li>ソフトウェア視点、OS を書くくらいの視点以上からは単に M コアであるとみなして
問題ない。</li>
<li>例: 8 コア 16 スレッド =&gt; OS からは CPU0..15 の 16 コアあるように見えるはず</li>
</ul>
</li>
<li>L1 キャッシュ (コアごと) SRAM</li>
<li>L2 キャッシュ (共通)</li>
<li>L3 キャッシュ (共通)</li>
<li>メモリ DRAM
<ul>
<li>CPU の速度向上に置いて行かれてとんでもなく遅い(だからキャッシュがある)。</li>
</ul>
</li>
</ul>
<h3 id="simultaneous-multi-threading-smt"><a class="header" href="#simultaneous-multi-threading-smt">Simultaneous Multi-Threading (SMT)</a></h3>
<p>N コア M スレッドの補足。
SMT と呼ばれる技術である。
Intel 用語だと Intel Hyper-Threading。</p>
<p>(CPU 設計上の狭い意味で) コアと呼ばれるものの1つ1つの中には、
演算器やメモリの読み書きユニット、L1 キャッシュのような各種ユニットが含まれている。</p>
<p>コアごとに各クロックで、1命令を細かく切り刻んだステージを複数命令分同時に実行していく
(パイプライン実行) のだが、その様子を観察するとハードウェアユニットを各クロックで
100% 使用していないということが分かった
(普通のプログラムを普通に動かして各ユニットが各クロックで 100% フル稼働するとは
考えにくい)。</p>
<p>そこで、あるユニットを使いたいときは隣のスレッドが使い終わるまで待つような調停を
入れつつ、物理コア内で2本のハードウェアスレッドを実行できるようにしたものである。
加算器やメモリロードストアユニットのようなよく使われるものはそれなりに競合するだろうし、
1コアあたり2スレッドとしたところで性能は2倍とはならない。
実際のところ、1.3 倍程度？らしい。</p>
<h2 id="スレッドライブラリ"><a class="header" href="#スレッドライブラリ">スレッドライブラリ</a></h2>
<p>だいたいのところ、関数をスレッド生成関数に渡すとそれを別スレッドとして
実行開始してくれることが多い。
スレッドの起動パラメータを渡せることもあれば、クロージャの環境キャプチャを使えと
言われることも。move セマンティクスに対応していると嬉しい。
ラムダ式があると記述が楽なこともあれば、大きなスレッドは普通に関数として書きたいことも。</p>
<p>join でスレッド終了の待ち合わせと返り値を受け渡せることが多い。
ただし実戦は別スレッドでのエラー (or 例外) 処理とリソースの解放義務が複雑に絡み合い
カオスになりがち。Rust を使おう。</p>
<h3 id="pthread"><a class="header" href="#pthread">pthread</a></h3>
<p>POSIX 標準の C API。</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

void *print_hello(void *arg) {
    printf("Hello, World!\n");
    return NULL;
}

int main() {
    pthread_t thread1;

    if (pthread_create(&amp;thread1, NULL, print_hello, NULL) != 0) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    if (pthread_join(thread1, NULL) != 0) {
        fprintf(stderr, "Error joining thread\n");
        return 1;
    }

    return 0;
}
</code></pre>
<h3 id="stdthread"><a class="header" href="#stdthread">std::thread</a></h3>
<p>余計な記述が少なく結構使いやすい。
スレッド内で発生した例外が join() で受け取れたり、結構頑張っている。</p>
<pre><code class="language-C++">#include &lt;cassert&gt;
#include &lt;thread&gt;

int main()
{
  int x = 0, y = 0;

  std::thread t([&amp;]{ ++x; });
  --y;
  t.join();

  assert(x == 1 &amp;&amp; y == -1);
  return 0;
}
</code></pre>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>スレッドセーフでないコードはコンパイルが通らない。</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<h2 id="競合状態-race-condition"><a class="header" href="#競合状態-race-condition">競合状態 (race condition)</a></h2>
<p>スレッド間で通信をするためには、メモリ空間を共有していることを考えると、
共有メモリを読み書きするのが手軽である。</p>
<p>以下は shared_mem を 256 スレッドから 1000000 回インクリメントするが、
256000000 にはならない (ことがある)。</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

void *proc(void *arg) {
  int *shared_mem = (int *)arg;
  for (int i = 0; i &lt; 1000000; i++) {
    (*shared_mem)++;
  }

  return NULL;
}

int main() {
  pthread_t th[256];
  int shared_mem = 0;

  for (int i = 0; i &lt; 256; i++) {
    if (pthread_create(&amp;th[i], NULL, proc, &amp;shared_mem) != 0) {
      fprintf(stderr, "Error creating thread\n");
      return 1;
    }
  }
  for (int i = 0; i &lt; 256; i++) {
    if (pthread_join(th[i], NULL) != 0) {
      fprintf(stderr, "Error joining thread\n");
      return 1;
    }
  }

  printf("shared_mem = %d\n", shared_mem);

  return 0;
}
</code></pre>
<p>このように何の工夫もなく複数のスレッドから共通のメモリを読み書きすると、色々と壊れる。
しかも確率的にごく稀に壊れることもある。
これを競合状態 (race condition)、スレッドセーフでない等という。</p>
<p>スレッドセーフでないコードが具体的にどうなるかは非常に説明が難しい。
当然ハードウェア実装にもよる。</p>
<p>昔ながらの教科書では以下のように説明されることが多いし、一旦はこれで納得すること。
でも～なケースなら大丈夫じゃないの？と思ったりするかもしれないが、
大抵の場合全然大丈夫じゃないので CPU 内部の挙動を説明できるレベルにない間は
必ずロックを取ること。</p>
<ol>
<li>スレッドAがメモリから値 0 を CPU 内に読む</li>
<li>スレッドBがメモリから値 0 を CPU 内に読む</li>
<li>スレッドAが CPU 内でインクリメントを行い、値 1 を CPU 内に用意する</li>
<li>スレッドAがメモリへ値 1 を書き込む</li>
<li>スレッドBが CPU 内でインクリメントを行い、値 1 を CPU 内に用意する</li>
<li>スレッドBがメモリへ値 1 を書き込む</li>
</ol>
<ul>
<li>まず、コンパイラの最適化がかかる。コンパイラ最適化はシングルスレッドでの実行結果が
変わらないことしか保証しない。
<ul>
<li><code>volatile int *</code> とすると、1000000 回メモリに書き込む機械語が生成されることは
保証される。ただし volatile 単独ではスレッドセーフにはならない。
巷にはインチキコードが溢れているので注意。</li>
</ul>
</li>
<li>高機能なプロセッサでは Out-of-Order 実行によって CPU の内部で機械語の実行順序を
並べ替えられる。こちらもシングルスレッドでの実行結果が変わらないことしか保証しない。
<ul>
<li>こんなとんでもないことをわざわざする理由については、CPU 設計のパイプラインと
命令間依存性、ハザードの話を参照。</li>
</ul>
</li>
<li>パイプライン実行によって1命令を数～数十ステージに分割し、何クロックもかけて、
他の命令と同時並列で実行する。</li>
<li>そのような CPU コアが複数あり、それぞれが同一クロックで独立して動いている。</li>
</ul>
<p>Note: 読み出しのみならセーフ。
メモリに置いた定数を複数スレッドから共有するのは問題ない。</p>
<p>そのままだとレースコンディションを起こしてしまうようなコード区間を
クリティカルセクションという。
クリティカルセクションを保護してスレッドセーフにするために待ち合わせ等を
行うことを同期をとる (synchronize) という。</p>
<h2 id="ロック-ミューテックス-mutex"><a class="header" href="#ロック-ミューテックス-mutex">ロック (ミューテックス, Mutex)</a></h2>
<p>ロックは同時に一人しか獲得する (acquire) ことができない同期プリミティブである。
とりあえずこれを覚えるだけで OK と言っても過言ではない。
クリティカルセクションが終了したら解放する (release)。</p>
<p>ロックが取れない場合、スレッドを sleep 状態
(カーネルのスケジューラによる管理状態の1つ) に入れてアンロックされるまで
スケジュールから外される。
ただしこれはコンテキストスイッチが伴いオーバーヘッドが大きいので、
ロックを持っているスレッドが他のコアにおり、相手がメモリを少しいじって
即アンロックするだけならばそのままビジーループで待った方が効率よい(マルチコアの場合)。
よって一定回数スピン (ビジーループ) して待ち、それでも取れないなら
スリープするという最適化がよく行われる。</p>
<h3 id="ユーザランドスピンロック-上級者向け"><a class="header" href="#ユーザランドスピンロック-上級者向け">ユーザランドスピンロック (上級者向け)</a></h3>
<p>スレッドをスリープに入れるとか、相手がアンロックした時に起きてくるとかは
カーネルランドでしかできないので、mutex lock/unlock には
システムコールを発行する必要がある。</p>
<p>それが嫌な場合、スリープを諦めることを条件に、
スピンロックをユーザランドで実装することは不可能ではない
(スピンロックを作るためのアトミック命令はユーザモードでも実行可能なため)。
ただし、ユーザモードのコードは常にタイマ割り込みによってカーネルにプリエンプトされる
可能性があり、それを防ぐ術もない。
ロックを持ったスレッドが CPU を奪われると、再度 CPU を割り当てられて
アンロックを実行するまで待っているスレッドはビジーループでそのコアを使用率 100% で
使い潰すことになる。
とはいえ、現代の PC/サーバ クラスのマルチコア環境で全コアを使い切っている状況は
ほとんどなく、持て余しているというのも実情である。
なので実行可能 (CPU 割り当て可能) 状態のスレッド数がコア数を上回り続けることは
ほとんどなく、ロックを持ったスレッドが CPU を奪われたままになり続けることは
ほとんどないと言えなくもない。</p>
<p>というわけで私からは評価不能である。
とりあえず、とあるデータベースソフトウェアがそのようなことをやっていて、
Linus からは pure garbage などという暴言を頂いたようだ。</p>
<h3 id="rwlock"><a class="header" href="#rwlock">RwLock</a></h3>
<p>読み出しはよく行われるが、書き換えは稀にしか起こらないようなケースがある。
複数の読み出しはロックなしで同時に行っても安全だが、
書き換え中は他のスレッドの読み出しと書き込み両方を禁止する必要がある。</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Read</th><th>Write</th></tr></thead><tbody>
<tr><td>Read</td><td>OK</td><td>NG</td></tr>
<tr><td>Write</td><td>NG</td><td>NG</td></tr>
</tbody></table>
</div>
<p>いずれか1つが Write アクセスの場合は Mutex と同じだが、
すべて Read アクセスの場合はロックなしの動作になるようなロックがあると効率がよい。
それが Read Write Lock または Exclusive Shared Lock と呼ばれるものである。
ファイルロックも同じような仕組みが提供されることが多い。</p>
<h2 id="条件変数-condition-variable"><a class="header" href="#条件変数-condition-variable">条件変数 (Condition Variable)</a></h2>
<p>ユーザランドで Mutex を使えば、ロックを取れなかったときにスレッドをスリープ状態にして
OS に CPU (コア) を他のスレッドに割り当ててもらって CPU を有効活用できる。
また、スリープ状態のスレッドは実行可能になったら適切に起こす (wake up) 必要がある。</p>
<p>このスリープをもっと汎用的に使えるように設計されたのが、条件変数である。
モニタパターンとも呼ばれる。
ちょっと使い方にクセがあって条件変数という名前も直感的でないが、
非常に汎用性が高く、一度覚えれば CPU を適切に割り当てるプログラムが書けるようになる。
条件変数という名前の由来は私もよく分からないので少なくとも名前の意味を
考えるのはやめておくのをおすすめする。</p>
<p>条件変数は単独で使用するのではなく、他の要素と同時にパターンに従って
使用されることを前提として設計されている。</p>
<ul>
<li>Mutex またはそれに類するロック</li>
<li>その Mutex で保護された変数群</li>
<li>その Mutex に関連付けられた条件変数とモニタ条件</li>
</ul>
<p>使い方は決まっているのでまずは使い方を丸覚えしたほうがよい。</p>
<pre><code class="language-C">// mutex = init_mutex();
// condvar = init_condvar(mutex);
mutex.lock();
while (!(condition)) {
  // unlock and sleep
  condvar.wait();
  // wakeup and lock
}
do_something1();
mutex.unlock();
</code></pre>
<ol>
<li>まず、とにもかくにもロックを取得し、クリティカルセクションに入る。</li>
<li>この時点で共有変数には自分一人しかアクセスできないことが保証されている。
ロックで保護された変数を読み取り、「条件」が満たされていないならば
その条件に対応させる「条件変数上で待機する (wait)」。
ここで、if 文ではなく while 文としておく。
理由は後述するが、最初は定型文として覚えてしまった方がよい。</li>
<li>wait は <strong>ロックを外し</strong>、このスレッドをスリープさせる。
対象の条件変数のモニタに入る、とも言う。</li>
<li>wait は 対象の条件変数に対して通知 (notify, signal, wakeup などと言われる)
が来ると起きる。これについては後述。
また、<strong>ロックを再度取得した状態で</strong> 起きてくる(そういう風に頑張って作られている)。</li>
<li>起床後、もう一度同じ条件を確認する。ロックを持った状態で起きてくるので安全である。
条件が満たされているのを確認できた場合はループを抜けて本処理に入る。
条件が満たされていない場合は前回と同様にもう一度 wait する。</li>
<li>満たされた条件のもと何らかの処理を行い、アンロックし、完了。</li>
</ol>
<p>while ループとしておき起床後に再度同じ条件をチェックする理由は</p>
<ul>
<li>spurious wakeup といって、起こされていないのに起きる可能性がある。
<ul>
<li>ほとんどのユーザランドライブラリで注意されている。</li>
</ul>
</li>
<li>他にも同じ条件変数で寝ているスレッドがあり、ロックを取りながら起きようとする際に
他のスレッドに負け、勝ったスレッドがロック状態のうちに条件を満たさないように
保護された変数を変更した場合、ロックを取れた頃には条件が満たされない状態に
なってしまっている。</li>
</ul>
<p>前者はユーザランドでどんな状況でも厳密に正しく実装するのが重すぎるから、らしいが
具体的なところはよくわからない。
シグナルによる EINTR のハンドリングが絡むとよくないとの噂がある。
Linux や FreeBSD のカーネル用関数では spurious wakeup は触れられておらず、
起きないのかもしれない。
しかし後者の問題は常に対応する必要があり、後者を対応すれば自然に前者にも
対応できるのだから、結論は簡単で常に while のロジックを使うべきである。</p>
<p>プログラミング言語やライブラリによっては <code>while (!(condition))</code> の condition の
部分をラムダ式等で渡せる (渡すしかない) ようになっているものもある。</p>
<ul>
<li>while を使わない等の間違った使い方を封殺する。</li>
<li>while の中に成立を待つ条件の否定を書かないといけないのを、
関数から肯定の条件を返すようにできる。</li>
</ul>
<pre><code class="language-C">// mutex = init_mutex();
// condvar = init_condvar(mutex);
mutex.lock();
do_something2();
if (condition) {
  condvar.notify_all();
}
mutex.unlock();
</code></pre>
<ol>
<li>起こす側も、まずロックは取得する。
起こす側と起こされる側を同一ロジックにすることも可能だが、使い方を理解すれば
自然にそのようにも書けるようになる。</li>
<li>ロックで保護された変数を操作し、もし条件が満たされるようになり
条件が満たされず寝ているスレッドがいるなら起こす必要がある場合、
notify 操作を行う。
notify_one, notify_all (wakeup_one, wakeup_all) のように複数の機能が提供
されている場合があるが、よほど自信がある場合以外は notify_all を強くおすすめする。</li>
<li>アンロックして完了。</li>
</ol>
<h2 id="注意-volatile-は罠"><a class="header" href="#注意-volatile-は罠">注意: volatile は罠</a></h2>
<p>CON02-C. volatile を同期用プリミティブとして使用しない</p>
<p><a href="https://www.jpcert.or.jp/sc-rules/c-con02-c.html">https://www.jpcert.or.jp/sc-rules/c-con02-c.html</a></p>
<p>volatile は主にメモリマップされたハードウェアレジスタを読み書きすることを
意図したもので、単体でスレッドセーフにする効果はない。
メモリアクセスをコンパイラ最適化で省略しないというのは共有メモリで通信する以上
必須ではあるのだが、それだけでは全然足りないためである。
生成される機械語が変わるので、レースバグの再現率を変える実験くらいにしか使えない。
レースバグは絶対に直らない。</p>
<ul>
<li>volatile オブジェクトへの読み書きのメモリアクセスは省略されない。
<ul>
<li>Memory Mapped I/O (メモリアクセス命令で特定レンジへのアクセスが
メインメモリではなく他のハードウェアデバイスへ飛んで制御できる方法。)
がうまくいくようになる。</li>
<li>2回異なるデータを同じ場所に書き込んだ時、1回目は無駄だからといって
省略してはならない。それは通常のメモリの場合であって、それ以外の
ハードウェアデバイスへの書き込みには意味がある可能性がある。
1を書き込んだタイミングで処理開始、とか。</li>
<li>複数回の同一アドレスからの読み出しも省略してはならない。
CPU 外のハードウェアは CPU とは独立して動作しており、
読み出される値は変更される可能性がある
(volatile = 揮発性 = 何もしなくても状態が勝手に変わる)。</li>
</ul>
</li>
<li>メモリを使わずレジスタだけで済ませるという最適化も無効。</li>
</ul>
<p>難しい話が分からない場合は、書き込みを伴う共有変数には必ずロックを使うこと。
ロックに代表される同期プリミティブと呼ばれるオブジェクトは、
難しい話を全てクリアしてある。</p>
<h2 id="アトミック命令-ここから上級者向け"><a class="header" href="#アトミック命令-ここから上級者向け">アトミック命令 (ここから上級者向け)</a></h2>
<p>古い OS の教科書にはピーターソンのアルゴリズムやデッカーのアルゴリズムなど、
ハードウェアサポートなしで同期を取ろうとする天才プログラムが載っていたりするが、
Out-of-Order + マルチコアのような現代の世紀末環境では全く通用しないし、
専用の命令をハードウェアに用意してもらった方が効率的で使い方も簡単である。</p>
<p>アトミック性 (atomicity) とは、不可分性と訳され、他の実行コンテキストから
その命令の実行前と実行後のどちらかの状態しか観測されないという性質のことである。
逆に言うとアトミックと明示的に言われない限りは保証されないと思っておいた方がよい。</p>
<p>アトミック性の概念自体は CPU の提供するアトミック命令だけではなく、
もっと広く用いられるものである。
例えばロックを取っている間に複数の変数を変更した場合、同じくロックを取ってアクセスする
他のスレッドからは、ロックを取る前かロックを解除した後の状態しか観測されない。</p>
<p>実際のところ、メモリアラインされた 32 bit ロード or ストアは
何もしなくてもアトミックになることが多い。
明示的にアトミック命令と言われた場合、read-modify-write (atomic-add, atomic-swap)
を指すことが多い。
メモリを読んで、それに何か計算をして、結果を書き込む、という操作は
典型的なレースコンディションを引き起こす操作だが、
現代の CPU ではそれくらいなら専用命令を呼ぶだけでアトミックに
処理できるということである。
アトミック命令は内部的にはバスロック (ハードウェア論理レベルでメモリバスを占有する) で
実装されることが多い、気がする。多分。</p>
<p>(アトミック命令で実装されている) ロックを使わずアトミック命令を直接呼ぶだけで
実現可能な単純なロジックならば、アトミック命令で実装した方が性能は上がる可能性が高い。
外部からのキャンセルリクエストのようなものならば atomic bool 等で十分かもしれない。
ただしスレッドセーフにしなければならないデータ構造が変数2つ以上になった瞬間
ロックで書き直さなければならなくなったりもする。
可読性やメンテナンス性とのトレードオフとなるのでよく考えること。</p>
<h2 id="メモリオーダリングメモリバリアフェンス"><a class="header" href="#メモリオーダリングメモリバリアフェンス">メモリオーダリング・メモリバリア・フェンス</a></h2>
<p>アトミック性自体はアトミック命令を呼べば実現するが、
アトミック性だけで十分なケースは大して多くない。</p>
<p>あるスレッドがメモリを書き換えたとき、その書き換えの順番が他のスレッドから
同じ順番で見えるとは保証されないことがあるからである。
コンパイラ最適化による命令の並べ替えもその一種と言えなくもないが、
こちらは volatile で制御できなくもない。
問題は CPU のアウトオブオーダ実行による CPU 内部での命令の並べ替えである。</p>
<p>現代の性能重視の CPU は、シングルスレッドで考えた実行結果が変わらないという制約の下で、
命令の実行順を入れ替えることがある。
これは現代 CPU の中でも最も複雑な部分と思われる。
アウトオブオーダ機能の自作はおすすめしないしデバッグも困難を極める。
なぜわざわざそんなことをするかというと、そうした方が速いケースがあるからである。
命令の (パイプライン化され細かく分かれたステージのうちの) 実行には入力オペランド
(例えば、足し算なら、その対象の2つのレジスタなど) が確定している必要があるが、
そのレジスタが直前の命令によって書き込まれる</p>
<h2 id="メモリモデル一貫性モデル"><a class="header" href="#メモリモデル一貫性モデル">メモリモデル・一貫性モデル</a></h2>
<h2 id="ロックの作り方"><a class="header" href="#ロックの作り方">ロックの作り方</a></h2>
<h3 id="割り込み禁止-シングルコア専用カーネルモード専用"><a class="header" href="#割り込み禁止-シングルコア専用カーネルモード専用">割り込み禁止 (シングルコア専用・カーネルモード専用)</a></h3>
<p>シングルコア限定で絶対にレースしない必殺技があって、それが割り込み禁止である。</p>
<p>CPU の割り込み機能はオフにできるため、そうしている間は突然実行コンテキストが切り替わる
ことが絶対にない (NMI (Non-Maskable Interrupt) は除く)。
タイマ割り込みも無効になる。</p>
<p>ただし当然、早急な処理を求められる外部ハードウェアへの応答が遅れるため、
長時間のロックはご法度である。
またこれも当然、カーネルモード (OS の中) でしか変更できない。</p>
<p>割り込みハンドラとの間でも同期が取れることになるが、
割り込みハンドラと変数を共有していない場合はプリエンプト禁止で十分かもしれない。
プリエンプト禁止は CPU のハードウェア設定ではなく、OS 上でのソフトウェア的な
制御になる。</p>
<h3 id="スピンロック-マルチコア向けカーネルモード向け"><a class="header" href="#スピンロック-マルチコア向けカーネルモード向け">スピンロック (マルチコア向け・カーネルモード向け)</a></h3>
<p>アトミック命令を使って初めに作ることになる、最も単純なロックである。
シングルコアではビジーウェイト (メモリの値が変わるまで読み続ける) は
他のスレッドにスイッチしてメモリが書き換えられるまで無駄に CPU 時間を消費するため
行儀の悪いスタイルと言われるが、マルチコアではビジーウェイト中も他のコアが動けるため、
ロック時間が十分短いならばコンテキストスイッチのコストがかからずむしろ
性能のよいロックとなる。
また、割り込みハンドラ同士または割り込みハンドラとスレッドコンテキストとの間の
ロックとしても使用可能である。</p>
<p>データ構造としては、ロック本体はメモリ上に 1 word 程度の整数を用意するだけで
ロック1つを実現できる。</p>
<p>xv6 (RISC-V) での実装</p>
<pre><code class="language-C">// Mutual exclusion lock.
struct spinlock {
  uint locked;       // Is the lock held?

  // For debugging:
  char *name;        // Name of lock.
  struct cpu *cpu;   // The cpu holding the lock.
};
</code></pre>
<p>スピンロックを取得した状態で解放前に自身のコアで割り込みが入り、
その割り込みハンドラで同じロックを取得しようとした場合、デッドロックして
コアが割り込みハンドラ内で固まってしまう。
そのため初めにローカルコア割り込みを OFF にしている。
割り込みハンドラからロックしないならば、これは不要とも言える。
ただしタイマ割り込みからのプリエンプトは禁止すべきだろう。
オープンソースの OS の実装を見て回るのもよい。</p>
<p>次の <code>__sync_lock_test_and_set()</code> がアトミック命令で、ロックの本体である。
アセンブラで直接書くか、このように gcc 拡張を使って多少ハードウェア非依存っぽく
書くこともできる。
このようなコンパイラ拡張は、コンパイラへの命令並べ替え禁止効果を含んでいて便利である。
自力でやるときは <code>asm volatile</code> と <code>memory</code> 指定を使う。</p>
<p><code>test_and_set</code> は名前と違って atomic_swap に近いらしい。
「メモリを読んで返す」のと「メモリに第二引数 (1) を書き込む」を同時に行い、
その途中状態を他のコアから観測されないようにする。
具体的にはメモリバスロックを行い、自分以外のコアのメモリアクセスを禁止するとか。多分。</p>
<p>コードとしてはメモリ内容と 1 をアトミックに交換し、0 が取得された場合は
ロックが取れた (ロック変数を0から1に変更した) とみなし、
1 が取得された場合はロックが取れなかった (ロック変数は1から1のまま) とみなす、
というだけのことである。
ロックのキモはたったこれだけではある。
両方のスレッドからアクセス可能な 1 word 程度のメモリがあれば実現できる。
ただし、現代の CPU では考慮すべき事項が多い。</p>
<pre><code class="language-C">// Acquire the lock.
// Loops (spins) until the lock is acquired.
void
acquire(struct spinlock *lk)
{
  push_off(); // disable interrupts to avoid deadlock.
  if(holding(lk))
    panic("acquire");

  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
  //   a5 = 1
  //   s1 = &amp;lk-&gt;locked
  //   amoswap.w.aq a5, a5, (s1)
  while(__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)
    ;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that the critical section's memory
  // references happen strictly after the lock is acquired.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Record info about lock acquisition for holding() and debugging.
  lk-&gt;cpu = mycpu();
}

// Release the lock.
void
release(struct spinlock *lk)
{
  if(!holding(lk))
    panic("release");

  lk-&gt;cpu = 0;

  // Tell the C compiler and the CPU to not move loads or stores
  // past this point, to ensure that all the stores in the critical
  // section are visible to other CPUs before the lock is released,
  // and that loads in the critical section occur strictly before
  // the lock is released.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Release the lock, equivalent to lk-&gt;locked = 0.
  // This code doesn't use a C assignment, since the C standard
  // implies that an assignment might be implemented with
  // multiple store instructions.
  // On RISC-V, sync_lock_release turns into an atomic swap:
  //   s1 = &amp;lk-&gt;locked
  //   amoswap.w zero, zero, (s1)
  __sync_lock_release(&amp;lk-&gt;locked);

  pop_off();
}
</code></pre>
<p>ロックを使わずアトミック命令でスレッドセーフに書く (ロック自体を作る時など)
ための条件は以下の通り。</p>
<ul>
<li>通常のメモリロードストア命令ではなくアトミック命令を使い、
途中の状態を他のコアから観測されないようにする。</li>
<li>コンパイラ最適化を無効にし、特定の行をまたいだ命令の並べ替えを防止する。</li>
<li>メモリバリア命令を置き、それをまたいだ CPU 内での命令の並べ替えを防止する。</li>
</ul>
<p>volatile の付与だけでは全然足りないことが分かる。
通常のロードストア命令は自然にアトミックになる CPU も多いが。</p>
<p>コンパイラによるコンパイル時の並べ替えと CPU による実行時の並べ替えは、
いつやるかが違うだけで概念としては同じものが使える。
メモリの読み書きの (物理的な) 順番の制御をメモリオーダリングと呼び、
手動でそれを防ぐ手段をメモリバリアと呼ぶ。</p>
<p>ちなみに x86 はメモリオーダリングに関してはかなり「堅い」方で、ARM や RISC-V は
「ゆるゆる」である。
Google が Android のために JVM を x86 から ARM に持っていったら
怪奇現象にしか見えないメモリオーダリングのバグに苦労したらしい…。</p>
<h3 id="スリープロック-普通のロック"><a class="header" href="#スリープロック-普通のロック">スリープロック (普通のロック)</a></h3>
<h2 id="ロックフリーアルゴリズム-初心者お断り"><a class="header" href="#ロックフリーアルゴリズム-初心者お断り">ロックフリーアルゴリズム (初心者お断り)</a></h2>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>共通しているのは見た目や使い勝手のみで、
具体的に何が起こるかはプログラミング言語ごとにバラバラで一概には言い難い。 <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="サバイバルツール類"><a class="header" href="#サバイバルツール類">サバイバルツール類</a></h1>
<h2 id="よく分からないファイルを調べる"><a class="header" href="#よく分からないファイルを調べる">よく分からないファイルを調べる</a></h2>
<p>ヘッダ情報をパースしてくれたり、テキストファイルならエンコーディングを調べてくれたり、
既に種類が分かっているファイル相手でもいい感じで要約された情報が得られる。</p>
<pre><code class="language-sh">$ file rshanghai
rshanghai: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV),
dynamically linked, interpreter /lib/ld-linux-aarch64.so.1,
BuildID[sha1]=82b09bf2c510acc4e66f5a8bd9b65d0120968da6,
for GNU/Linux 3.7.0, not stripped

$ file yappy_house_full.jpg
yappy_house_full.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI),
density 350x350, segment length 16, Exif Standard:
[TIFF image data, big-endian, direntries=14],
baseline, precision 8, 3118x3118, components 3

$ file src/tools.md
src/tools.md: Unicode text, UTF-8 text
</code></pre>
<h2 id="バイナリファイルのうち文字列として解釈可能な部分を表示"><a class="header" href="#バイナリファイルのうち文字列として解釈可能な部分を表示">バイナリファイルのうち文字列として解釈可能な部分を表示</a></h2>
<p>何らかの手掛かりを得たい場合や、
バイナリファイルに流出するとまずい情報が含まれていないか調べる時などに。</p>
<p><code>-n &lt;文字数&gt;</code> で最低文字列長を指定できる。
デフォルトは 4 らしい。</p>
<pre><code class="language-sh">$ strings rshanghai
/lib/ld-linux-aarch64.so.1
_ITM_deregisterTMCloneTable
__gmon_start__
_ITM_registerTMCloneTable
SSL_get_verify_result
SSL_shutdown
SSL_CTX_new
SSL_set_verify
SSL_get0_param
SSL_CTX_get_cert_store
...
</code></pre>
<h2 id="バイナリ表示"><a class="header" href="#バイナリ表示">バイナリ表示</a></h2>
<pre><code class="language-sh">$ xxd rshanghai | head
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0300 b700 0100 0000 c070 1a00 0000 0000  .........p......
00000020: 4000 0000 0000 0000 6831 0302 0000 0000  @.......h1......
00000030: 0000 0000 4000 3800 0a00 4000 2000 1f00  ....@.8...@. ...
00000040: 0600 0000 0400 0000 4000 0000 0000 0000  ........@.......
00000050: 4000 0000 0000 0000 4000 0000 0000 0000  @.......@.......
00000060: 3002 0000 0000 0000 3002 0000 0000 0000  0.......0.......
00000070: 0800 0000 0000 0000 0300 0000 0400 0000  ................
00000080: 7002 0000 0000 0000 7002 0000 0000 0000  p.......p.......
00000090: 7002 0000 0000 0000 1b00 0000 0000 0000  p...............

$ xxd -g 1 rshanghai | head
00000000: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 03 00 b7 00 01 00 00 00 c0 70 1a 00 00 00 00 00  .........p......
00000020: 40 00 00 00 00 00 00 00 68 31 03 02 00 00 00 00  @.......h1......
00000030: 00 00 00 00 40 00 38 00 0a 00 40 00 20 00 1f 00  ....@.8...@. ...
00000040: 06 00 00 00 04 00 00 00 40 00 00 00 00 00 00 00  ........@.......
00000050: 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  @.......@.......
00000060: 30 02 00 00 00 00 00 00 30 02 00 00 00 00 00 00  0.......0.......
00000070: 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  ................
00000080: 70 02 00 00 00 00 00 00 70 02 00 00 00 00 00 00  p.......p.......
00000090: 70 02 00 00 00 00 00 00 1b 00 00 00 00 00 00 00  p...............

# エンディアンのせいで変。。
$ hexdump rshanghai | head
0000000 457f 464c 0102 0001 0000 0000 0000 0000
0000010 0003 00b7 0001 0000 70c0 001a 0000 0000
0000020 0040 0000 0000 0000 3168 0203 0000 0000
0000030 0000 0000 0040 0038 000a 0040 0020 001f
0000040 0006 0000 0004 0000 0040 0000 0000 0000
0000050 0040 0000 0000 0000 0040 0000 0000 0000
0000060 0230 0000 0000 0000 0230 0000 0000 0000
0000070 0008 0000 0000 0000 0003 0000 0004 0000
0000080 0270 0000 0000 0000 0270 0000 0000 0000
0000090 0270 0000 0000 0000 001b 0000 0000 0000

# -C でいい感じになる
$ hexdump -C rshanghai | head
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  03 00 b7 00 01 00 00 00  c0 70 1a 00 00 00 00 00  |.........p......|
00000020  40 00 00 00 00 00 00 00  68 31 03 02 00 00 00 00  |@.......h1......|
00000030  00 00 00 00 40 00 38 00  0a 00 40 00 20 00 1f 00  |....@.8...@. ...|
00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000050  40 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |@.......@.......|
00000060  30 02 00 00 00 00 00 00  30 02 00 00 00 00 00 00  |0.......0.......|
00000070  08 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00  |................|
00000080  70 02 00 00 00 00 00 00  70 02 00 00 00 00 00 00  |p.......p.......|
00000090  70 02 00 00 00 00 00 00  1b 00 00 00 00 00 00 00  |p...............|

# octal dump なのでデフォルトは8進数になる
$ od rshanghai | head
0000000 042577 043114 000402 000001 000000 000000 000000 000000
0000020 000003 000267 000001 000000 070300 000032 000000 000000
0000040 000100 000000 000000 000000 030550 001003 000000 000000
0000060 000000 000000 000100 000070 000012 000100 000040 000037
0000100 000006 000000 000004 000000 000100 000000 000000 000000
0000120 000100 000000 000000 000000 000100 000000 000000 000000
0000140 001060 000000 000000 000000 001060 000000 000000 000000
0000160 000010 000000 000000 000000 000003 000000 000004 000000
0000200 001160 000000 000000 000000 001160 000000 000000 000000
0000220 001160 000000 000000 000000 000033 000000 000000 000000

# 16進デフォルトは 16 bit ごとの上にエンディアンのせいで変。。
$ od -x rshanghai | head
0000000 457f 464c 0102 0001 0000 0000 0000 0000
0000020 0003 00b7 0001 0000 70c0 001a 0000 0000
0000040 0040 0000 0000 0000 3168 0203 0000 0000
0000060 0000 0000 0040 0038 000a 0040 0020 001f
0000100 0006 0000 0004 0000 0040 0000 0000 0000
0000120 0040 0000 0000 0000 0040 0000 0000 0000
0000140 0230 0000 0000 0000 0230 0000 0000 0000
0000160 0008 0000 0000 0000 0003 0000 0004 0000
0000200 0270 0000 0000 0000 0270 0000 0000 0000
0000220 0270 0000 0000 0000 001b 0000 0000 0000

$ od -t x1 rshanghai | head
0000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
0000020 03 00 b7 00 01 00 00 00 c0 70 1a 00 00 00 00 00
0000040 40 00 00 00 00 00 00 00 68 31 03 02 00 00 00 00
0000060 00 00 00 00 40 00 38 00 0a 00 40 00 20 00 1f 00
0000100 06 00 00 00 04 00 00 00 40 00 00 00 00 00 00 00
0000120 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00
0000140 30 02 00 00 00 00 00 00 30 02 00 00 00 00 00 00
0000160 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00
0000200 70 02 00 00 00 00 00 00 70 02 00 00 00 00 00 00
0000220 70 02 00 00 00 00 00 00 1b 00 00 00 00 00 00 00
</code></pre>
<p>コマンドラインパラメータを覚えられないので、デフォルトで見やすい <code>xxd</code> を
第一選択肢に覚えておくのがいい気がする。
コマンド名の覚えやすさで行くなら <code>hexdump -C</code>。</p>
<p>なんでいろいろあるの？</p>
<ul>
<li>xxd は vim についてくるツールらしい。</li>
<li>hexdump は BSD 由来で Linux にも入っている系らしい。</li>
<li>od は由緒正しく POSIX でも規定されているコマンドらしい。
<ul>
<li>由緒正しすぎて 8 進ダンプは現代ではほぼ使われないのではないかとも思う。</li>
</ul>
</li>
</ul>
<h2 id="バイナリファイルを編集する"><a class="header" href="#バイナリファイルを編集する">バイナリファイルを編集する</a></h2>
<p><code>xxd</code> が vim についてくるというのはこうやって使えということらしい。
<del>やったことがない。</del>
<code>xxd -r</code> でテキストダンプからバイナリに逆変換できる。</p>
<pre><code class="language-sh">$ vi -b file.bin
:%!xxd
:%!xxd -r
:wq
</code></pre>
<h2 id="バイナリファイルを-c-ヘッダに変換する"><a class="header" href="#バイナリファイルを-c-ヘッダに変換する">バイナリファイルを C ヘッダに変換する</a></h2>
<p>こういうのでいいんだよこういうので。
圧倒的なポータビリティを誇る。</p>
<pre><code class="language-sh">$ xxd -i rshanghai | head
unsigned char rshanghai[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xb7, 0x00, 0x01, 0x00, 0x00, 0x00,
  0xc0, 0x70, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x68, 0x31, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x0a, 0x00, 0x40, 0x00,
  0x20, 0x00, 0x1f, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00,

# -C で変数名を大文字に
# -name で変数名を変更
$ xxd -i -C -name myname rshanghai | head
unsigned char MYNAME[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xb7, 0x00, 0x01, 0x00, 0x00, 0x00,
  0xc0, 0x70, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x68, 0x31, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x0a, 0x00, 0x40, 0x00,
  0x20, 0x00, 0x1f, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00,
</code></pre>
<h2 id="バイナリファイルをオブジェクトファイルに変換してリンクする"><a class="header" href="#バイナリファイルをオブジェクトファイルに変換してリンクする">バイナリファイルをオブジェクトファイルに変換してリンクする</a></h2>
<p>objcopy はオブジェクトファイルのコピーを行うが、ただのフルコピーなら <code>cp</code> コマンドで
いい訳で、実質的にフォーマット変換コマンドである。
<code>-I</code> や <code>-O</code> で入出力フォーマットを指定できるが、ここに <code>binary</code> が指定可能である。</p>
<pre><code class="language-sh"># -B を指定しないとリンカエラーになる気がする
$ objcopy -I binary -O elf64-little yappy_house.jpg  yappy_house.o
</code></pre>
<p>デフォルトだと <code>.data</code> (読み書き可能グローバル変数領域) セクションに
配置されてしまうので、気になるなら <code>--rename-section</code> を使う。
man に例があるので
<code>--rename-section .data=.rodata,alloc,load,readonly,data,contents</code>
をコピーして使えばよさそう。</p>
<pre><code class="language-sh">$ man objcopy
--rename-section oldname=newname[,flags]
    Rename a section from oldname to newname, optionally changing the section's
    flags to flags in the process.
    This has the advantage over using a linker script to perform the rename
    in that the output stays as an
    object file and does not become a linked executable.
    This option accepts the same set of flags as the
    --sect-section-flags option.

    This option is particularly helpful when the input format is binary,
    since this will always create a
    section called .data.  If for example, you wanted instead to create
    a section called .rodata containing
    binary data you could use the following command line to achieve it:

              objcopy -I binary -O &lt;output_format&gt; -B &lt;architecture&gt; \
              --rename-section .data=.rodata,alloc,load,readonly,data,contents \
              &lt;input_binary_file&gt; &lt;output_object_file&gt;
</code></pre>
<p>オブジェクトファイルには以下のようなシンボルが定義される。</p>
<pre><code class="language-sh">$ nm yappy_house.o
00000000000218b7 D _binary_yappy_house_jpg_end
00000000000218b7 A _binary_yappy_house_jpg_size
0000000000000000 D _binary_yappy_house_jpg_start

# リンク後
$ nm a.out | grep _binary
00000000000418ef D _binary_yappy_house_jpg_end
00000000000218b7 A _binary_yappy_house_jpg_size
0000000000020038 D _binary_yappy_house_jpg_start
</code></pre>
<p>size は分かりづらいが、absolute シンボルとして定義され、リンクしても値が変わらない。
シンボルアドレスがファイルサイズになっている。
なので奇数サイズのファイルの場合、奇数アドレスのシンボルができる。気持ち悪い。
1 byte 型のポインタとして <code>end - start</code> を計算すれば出てくるので、
size は使わなくてもいいかもしれない…。</p>
<p>C 以外で用意したシンボルを C から参照する際は型で混乱しやすいので注意。
シンボル情報のレベルでは型情報が消えているので無難な 1 byte 型にしてやるとよい。</p>
<pre><code class="language-C">// unsigned char _binary_yappy_house_jpg_start[SIZE] = {...};
// を定義すると
// "_binary_yappy_house_jpg_start"
// という配列の先頭アドレスを指すシンボルが生成されると考える
extern const unsigned char _binary_yappy_house_jpg_start[];
extern const unsigned char _binary_yappy_house_jpg_end[];
</code></pre>
<h2 id="elf-ファイル情報"><a class="header" href="#elf-ファイル情報">ELF ファイル情報</a></h2>
<p>ELF (Exectable and Linking Format) は名前の通り、実行可能形式および
その前のリンク中のデータのフォーマット。
EXE (PE) と違ってまだ実行可能でないオブジェクトファイルもこの形式で出力される。</p>
<p>実は file コマンドでも結構それなりに表示される。</p>
<pre><code class="language-sh">$ file /usr/bin/ls
/usr/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV),
dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]
=15dfff3239aa7c3b16a71e6b2e3b6e4009dab998, for GNU/Linux 3.2.0, stripped
</code></pre>
<p><code>readelf -h</code> でヘッダをパースしてくれる。</p>
<pre><code class="language-sh">$ readelf -h /usr/bin/ls
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2 s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Position-Independent Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x61d0
  Start of program headers:          64 (bytes into file)
  Start of section headers:          149360 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 30
</code></pre>
<p>ELF ヘッダに続くプログラムヘッダは <code>readelf -l</code> で。
ファイル中の何バイト目から何バイトをメモリの何バイト目にロードすれば
よいかが書かれている。</p>
<pre><code class="language-sh">$ readelf -l /usr/bin/ls

Elf file type is DYN (Position-Independent Executable file)
Entry point 0x61d0
There are 13 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x00000000000036c0 0x00000000000036c0  R      0x1000
  LOAD           0x0000000000004000 0x0000000000004000 0x0000000000004000
                 0x0000000000015759 0x0000000000015759  R E    0x1000
  LOAD           0x000000000001a000 0x000000000001a000 0x000000000001a000
                 0x0000000000008ed0 0x0000000000008ed0  R      0x1000
  LOAD           0x00000000000232b0 0x00000000000232b0 0x00000000000232b0
                 0x0000000000001310 0x00000000000025f8  RW     0x1000
  DYNAMIC        0x0000000000023d98 0x0000000000023d98 0x0000000000023d98
                 0x00000000000001f0 0x00000000000001f0  RW     0x8
  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000020 0x0000000000000020  R      0x8
  NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000020 0x0000000000000020  R      0x8
  GNU_EH_FRAME   0x000000000001ef7c 0x000000000001ef7c 0x000000000001ef7c
                 0x00000000000009fc 0x00000000000009fc  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x00000000000232b0 0x00000000000232b0 0x00000000000232b0
                 0x0000000000000d50 0x0000000000000d50  R      0x1
</code></pre>
<p>セクションヘッダは <code>readelf -S</code>。
.text や .data、.bss などのセクション (に加えて意味の分からないものも大量に)
が見える。</p>
<pre><code class="language-sh">$ readelf -S /usr/bin/ls
There are 31 section headers, starting at offset 0x24770:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000000318  00000318
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.gnu.pr[...] NOTE             0000000000000338  00000338
       0000000000000020  0000000000000000   A       0     0     8
  [ 3] .note.gnu.bu[...] NOTE             0000000000000358  00000358
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c
       0000000000000020  0000000000000000   A       0     0     4
  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0
       00000000000000b8  0000000000000000   A       6     0     8
  [ 6] .dynsym           DYNSYM           0000000000000458  00000458
       0000000000000be8  0000000000000018   A       7     1     8
  [ 7] .dynstr           STRTAB           0000000000001040  00001040
       00000000000005d9  0000000000000000   A       0     0     1
  [ 8] .gnu.version      VERSYM           000000000000161a  0000161a
       00000000000000fe  0000000000000002   A       6     0     2
  [ 9] .gnu.version_r    VERNEED          0000000000001718  00001718
       00000000000000d0  0000000000000000   A       7     2     8
  [10] .rela.dyn         RELA             00000000000017e8  000017e8
       0000000000001560  0000000000000018   A       6     0     8
  [11] .rela.plt         RELA             0000000000002d48  00002d48
       0000000000000978  0000000000000018  AI       6    25     8
  [12] .init             PROGBITS         0000000000004000  00004000
       0000000000000017  0000000000000000  AX       0     0     4
  [13] .plt              PROGBITS         0000000000004020  00004020
       0000000000000660  0000000000000010  AX       0     0     16
  [14] .plt.got          PROGBITS         0000000000004680  00004680
       0000000000000030  0000000000000008  AX       0     0     8
  [15] .text             PROGBITS         00000000000046b0  000046b0
       000000000001509e  0000000000000000  AX       0     0     16
  [16] .fini             PROGBITS         0000000000019750  00019750
       0000000000000009  0000000000000000  AX       0     0     4
  [17] .rodata           PROGBITS         000000000001a000  0001a000
       0000000000004f7a  0000000000000000   A       0     0     32
  [18] .eh_frame_hdr     PROGBITS         000000000001ef7c  0001ef7c
       00000000000009fc  0000000000000000   A       0     0     4
  [19] .eh_frame         PROGBITS         000000000001f978  0001f978
       0000000000003558  0000000000000000   A       0     0     8
  [20] .init_array       INIT_ARRAY       00000000000232b0  000232b0
       0000000000000008  0000000000000008  WA       0     0     8
  [21] .fini_array       FINI_ARRAY       00000000000232b8  000232b8
       0000000000000008  0000000000000008  WA       0     0     8
  [22] .data.rel.ro      PROGBITS         00000000000232c0  000232c0
       0000000000000ad8  0000000000000000  WA       0     0     32
  [23] .dynamic          DYNAMIC          0000000000023d98  00023d98
       00000000000001f0  0000000000000010  WA       7     0     8
  [24] .got              PROGBITS         0000000000023f88  00023f88
       0000000000000050  0000000000000008  WA       0     0     8
  [25] .got.plt          PROGBITS         0000000000023fe8  00023fe8
       0000000000000340  0000000000000008  WA       0     0     8
  [26] .data             PROGBITS         0000000000024340  00024340
       0000000000000280  0000000000000000  WA       0     0     32
  [27] .bss              NOBITS           00000000000245c0  000245c0
       00000000000012e8  0000000000000000  WA       0     0     32
  [28] .gnu_debugaltlink PROGBITS         0000000000000000  000245c0
       0000000000000049  0000000000000000           0     0     1
  [29] .gnu_debuglink    PROGBITS         0000000000000000  0002460c
       0000000000000034  0000000000000000           0     0     4
  [30] .shstrtab         STRTAB           0000000000000000  00024640
       000000000000012f  0000000000000000           0     0     1
</code></pre>
<h3 id="シンボル一覧"><a class="header" href="#シンボル一覧">シンボル一覧</a></h3>
<p><code>nm</code> が便利。
strip されていると消えて見えない。。</p>
<pre><code class="language-sh">$ nm /usr/bin/ls
nm: /usr/bin/ls: no symbols
</code></pre>
<p>シンボルタイプは1文字で表されるが、覚えられない。
<code>U</code> (おそらく undefined) が未定義シンボル (他のファイルにあるシンボルへの参照) で、
リンク時に他のオブジェクトファイルから提供される必要がある。</p>
<p>なお、libc (C 標準ライブラリ) などは基本的に動的リンクが選択されるので、
実行可能形式までリンクされた後でもまだ未解決シンボルは残る。
動的リンク周りは理屈自体はそこまで難しくはない
(リンカの行っている作業を一部実行時にまで遅延させているだけ) ものの、
実際にその動作を追おうとすると、全人類がお世話になっている割には
書いた人しか分からない魔境と化しているため踏み入るには注意が必要。</p>
<pre><code class="language-sh">$ nm rshanghai | grep U
                 U abort@GLIBC_2.2.5
                 U accept4@GLIBC_2.10
                 U bcmp@GLIBC_2.2.5
                 U bind@GLIBC_2.2.5
                 U BIO_clear_flags@OPENSSL_3.0.0
                 U BIO_get_data@OPENSSL_3.0.0
                 U BIO_meth_free@OPENSSL_3.0.0
                 U BIO_meth_new@OPENSSL_3.0.0
                 U BIO_meth_set_create@OPENSSL_3.0.0
                 U BIO_meth_set_ctrl@OPENSSL_3.0.0
                 U BIO_meth_set_destroy@OPENSSL_3.0.0
                 U BIO_meth_set_puts@OPENSSL_3.0.0
                 U BIO_meth_set_read@OPENSSL_3.0.0
                 U BIO_meth_set_write@OPENSSL_3.0.0
                 U BIO_new@OPENSSL_3.0.0
                 U BIO_set_data@OPENSSL_3.0.0
                 U BIO_set_flags@OPENSSL_3.0.0
                 U BIO_set_init@OPENSSL_3.0.0
                 U calloc@GLIBC_2.2.5
                 U ceilf@GLIBC_2.2.5
                 U ceil@GLIBC_2.2.5
                 U chdir@GLIBC_2.2.5
                 U chown@GLIBC_2.2.5
                 U chroot@GLIBC_2.2.5
...
</code></pre>
<p>シンボルはアドレスに振られたラベルであり、型情報は消えている。
なので変数や関数の型 (シグネチャ) と名前を書いたヘッダファイルは複数ソース間で
同じものを使わないとリンクまで成功してしまい、実行時に壊れる。
また、アドレスはリンクして実行可能ファイルになるまでは仮の値
(ゼロスタート) になっている。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インラインアセンブラ"><a class="header" href="#インラインアセンブラ">インラインアセンブラ</a></h1>
<p>C/C++ ソースの中にアセンブラを埋め込める。
C コードの途中にだいたいどこでも埋め込めるため、気軽にアセンブラ入門できる。</p>
<ul>
<li>アセンブラのソースファイルを用意する、ビルドシステムを整備するのが面倒。</li>
<li>関数の引数や返り値、スタックの処理は C に任せたい。</li>
</ul>
<p>こんな時におすすめ。
C の <code>main()</code> を呼ぶ前のスタートアップルーチンはアセンブラのソースファイルを
用意した方がいいかも。</p>
<h2 id="注意"><a class="header" href="#注意">注意</a></h2>
<ul>
<li>アセンブリ命令は機械語と対応しているので他ハードウェアへの移植性は諦めること。</li>
<li>AT&amp;T 表記の GAS (GNU Assembler) と Intel 表記の MASM
(Microsoft Macro Assembler) でオペランドの src と dst の順番が逆という
とんでもない罠があるので注意。</li>
<li>CPU が同じなら同じ命令が使えるはずというのはともかく、アセンブラへの命令は
標準仕様もクソもありません。そういうのは諦めてください。</li>
<li>互換性とか一般性とかは捨てる必要があるので、GAS を説明します。
これが分かれば他でも生き延びられる。</li>
</ul>
<h2 id="gas-gnu-assembler"><a class="header" href="#gas-gnu-assembler">GAS (GNU ASsembler)</a></h2>
<p>多分新しそうなマニュアルへのリンク</p>
<p><a href="https://sourceware.org/binutils/docs/as/">https://sourceware.org/binutils/docs/as/</a></p>
<pre><code class="language-sh"># コマンド名は as
# 通常は gcc から自動で呼ばれる
as --version
</code></pre>
<h2 id="c-コンパイル-広義-の流れ"><a class="header" href="#c-コンパイル-広義-の流れ">C コンパイル (広義) の流れ</a></h2>
<ol>
<li>C ソース (*.c)</li>
<li>プリプロセス (#include や #define 等を処理する)</li>
<li>プリプロセス済み C ソース</li>
<li>コンパイル (狭義) (C をアセンブラに変換する)</li>
<li>アセンブリソース (*.s)</li>
<li>アセンブル (アセンブラを機械語に変換する)</li>
<li>オブジェクトファイル (*.o) (機械語だが、外部グローバル変数や関数への参照が未解決)</li>
<li>リンク</li>
<li>実行可能ファイル or ライブラリファイル</li>
</ol>
<p>ちなみにコンパイラを自作する場合はアセンブラを出力してアセンブルとリンクを
既存ツールに任せると楽。Rust もそうしている。</p>
<h2 id="関連コマンド"><a class="header" href="#関連コマンド">関連コマンド</a></h2>
<p>実行可能ファイルまでリンクせず、オブジェクトファイル <code>*.o</code> の生成までで止める。</p>
<pre><code class="language-sh">gcc -c src.c
</code></pre>
<p>C コンパイルの後、アセンブラの生成で止める。拡張子は <code>*.s</code>。
これをアセンブルすると <code>*.o</code> ができる。</p>
<pre><code class="language-sh">gcc -S src.c
</code></pre>
<p>gcc は C コンパイラではなく総合フロントエンドなので、アセンブルしたいなら
<code>*.s</code> ファイルをそのまま渡せばよい。</p>
<pre><code class="language-sh"># make src.o (not an execuable)
gcc -c src.s
</code></pre>
<p>プリプロセスで止める。</p>
<pre><code class="language-sh">gcc -E src.c
</code></pre>
<p>オブジェクトファイルをディスアセンブルする。</p>
<pre><code class="language-sh">objdump -d src.o
</code></pre>
<h2 id="例"><a class="header" href="#例">例</a></h2>
<p>C ソース</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
        puts("hello");
        return 0;
}
</code></pre>
<p>機械語とディスアセンブル</p>
<pre><code class="language-text">$ gcc -O3 -g0 src.c
$ objdump -d src.o

src.o:     file format elf64-x86-64


Disassembly of section .text.startup:

0000000000000000 &lt;main&gt;:
   0:   48 83 ec 08             sub    $0x8,%rsp
   4:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # b &lt;main+0xb&gt;
   b:   e8 00 00 00 00          call   10 &lt;main+0x10&gt;
  10:   31 c0                   xor    %eax,%eax
  12:   48 83 c4 08             add    $0x8,%rsp
  16:   c3                      ret
</code></pre>
<p>コンパイラの吐いたアセンブリソース</p>
<pre><code class="language-asm">        .file   "src.c"
        .text
        .section        .rodata.str1.1,"aMS",@progbits,1
.LC0:
        .string "hello"
        .section        .text.startup,"ax",@progbits
        .p2align 4
        .globl  main
        .type   main, @function
main:
.LFB11:
        .cfi_startproc
        subq    $8, %rsp
        .cfi_def_cfa_offset 16
        leaq    .LC0(%rip), %rdi
        call    puts@PLT
        xorl    %eax, %eax
        addq    $8, %rsp
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE11:
        .size   main, .-main
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"
        .section        .note.GNU-stack,"",@progbits
</code></pre>
<p>謎の呪文が多くて気持ち悪くなるが、そういうところはコンパイラに任せて
インラインアセンブラを使おう。</p>
<p>抵抗感を軽減するための解説</p>
<ul>
<li>.file とかのドットで始まる指令
<ul>
<li>ディレクティブと呼ばれるもので、機械語命令を置くのではなく
アセンブラへの指令を出せる。マニュアルを検索すると出てくるはず。</li>
<li>.section
<ul>
<li>elf (オブジェクトファイルや実行可能ファイルのフォーマット) の
どの名前のセクションに入れるかを指定する。
<ul>
<li>text: プログラムコードを入れるセクション。思いっきり機械語のバイナリが
入っているので、名前がミスリーディング。
名前の由来はよく分からない。</li>
<li>data: グローバル変数が入っている。
elf ファイルに初期値イメージが入っている。</li>
<li>bss: ゼロ初期化されるグローバル変数が入っている。
elf ファイルにデータのコピーが入っておらず、メモリレンジの情報だけが入る。
main() 関数に入る前にゼロフィルする必要がある。</li>
<li>rodata: Read Only DATA。data のリードオンリー版。
文字列リテラルの本体もここに入る。</li>
</ul>
</li>
</ul>
</li>
<li>.string
<ul>
<li>文字列データをここに置く。他にも <code>.byte</code> <code>.word</code> などで定数リテラルを
そのまま置ける。</li>
</ul>
</li>
<li>.globl
<ul>
<li>シンボルをグローバルにする。要は他のオブジェクトファイルとリンクできるようにする。
C で言うと static のついていないグローバル変数・関数にする。
<del>なんで C はデフォルトが外部リンケージなんだ。</del></li>
</ul>
</li>
<li>.cfi_* 系
<ul>
<li>謎のデバッグ用情報。あまり気にしなくてよし。</li>
</ul>
</li>
<li>.include, .incbin
外部ファイルを読み込んでインクルードする。
なんと外部バイナリを読んでその場所に置ける。</li>
</ul>
</li>
<li>インデントなしでコロンで終わっている識別子
<ul>
<li>ラベル。アドレスとして本文から参照できる。</li>
<li>他のオブジェクトファイルに公開したい場合は .globl を使う。</li>
</ul>
</li>
<li>インデントされていてドットで始まっていないもの
<ul>
<li>CPU 命令。</li>
<li>…と見せかけて疑似命令 (1つ、または複数の CPU 命令に変換される
アセンブラ提供の便利機能) のこともある。</li>
<li>疑似命令は逆アセンブルすると正体を現すかもしれないし、逆アセンブラが気を利かせて
疑似命令で表示してくれるかもしれない。</li>
<li>なんだか疑似命令をディレクティブのこととして説明している文書も多く見つかるが、
そもそも情報少なすぎるし細かいことは気にしなくていいです。</li>
</ul>
</li>
</ul>
<h2 id="インラインアセンブラの書き方"><a class="header" href="#インラインアセンブラの書き方">インラインアセンブラの書き方</a></h2>
<p>多分新しそうなマニュアルへのリンク</p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html</a></p>
<p>アセンブラが機械語と一対一だというのが妄言だと理解したら、
インラインアセンブラの移植性皆無で超絶便利な機能を理解する準備ができたといえる。</p>
<p>アセンブラが扱うのはレジスタだが、C では変数という抽象的な概念を操作している。
アセンブラを書くとなると C との間で変数の受け渡しが非常にしたくなるところだが、
インラインアセンブラの文法はこの受け渡しをきれいに行ってくれる。
また、レジスタ入出力の依存性をしっかり書けば、最適化の恩恵を受けることもできる
(volatile で拒否することもできる)。</p>
<pre><code class="language-C">asm volatile ("template" : output : input : clobber);
</code></pre>
<ul>
<li>volatile
<ul>
<li>これをつけないと入力レジスタから出力レジスタを生成するだけの命令列として
最適化の対象になるが、これをつけるとこの最適化を無効にする。</li>
<li>副作用のある命令を書く場合は必ず必要。</li>
</ul>
</li>
<li>template
<ul>
<li>アセンブラのテンプレート。
ここから特定の文字列を入出力レジスタ名に自動で置換してくれたりする。</li>
</ul>
</li>
<li>output
<ul>
<li>出力オペランド指定。</li>
</ul>
</li>
<li>input
<ul>
<li>入力オペランド指定。</li>
</ul>
</li>
<li>clobber
<ul>
<li>このアセンブラで破壊されるレジスタ。</li>
<li>"memory" を指定するとメモリの読み書きを行うことをコンパイラに通知する。
実質的にコンパイラに対するメモリバリアとなる
(このアセンブラをまたいだメモリ読み書き命令の並べ替え抑止)。
プロセッサによる投機実行は防げない。</li>
</ul>
</li>
</ul>
<p>マニュアル中の例。</p>
<pre><code class="language-C">void do_print(uint32_t dwSomeValue)
{
   uint32_t dwRes;

   for (uint32_t x=0; x &lt; 5; x++)
   {
      // Assumes dwSomeValue is not zero.
      asm ("bsfl %1,%0"
        : "=r" (dwRes)
        : "r" (dwSomeValue)
        : "cc");

      printf("%u: %u %u\n", x, dwSomeValue, dwRes);
   }
}
</code></pre>
<ul>
<li>bsfl は x86 の Bit Scan Forward 命令で、1が立っているビットの中で最下位のものの
インデックスを返す命令らしい。</li>
<li>テンプレート文字列中の <code>%0</code> や <code>%1</code> は、続く入出力オペランド指定で渡された
値に該当する文字列に置換される。
<ul>
<li>ここでは C の引数やローカル変数をレジスタ指定で与えているため、
コンパイラの決めたレジスタ名に置換される。</li>
</ul>
</li>
<li>出力オペランドを <code>"=r" (dwRes)</code> のように記述することで、C のローカル変数 <code>dwRes</code> に
対応するレジスタに値が書き込まれることをコンパイラに伝えることができる。
<ul>
<li><code>=</code> は書き込みを示す。</li>
<li><code>r</code> は値のタイプで、レジスタを示す。ここを変えれば即値を渡せたりもする、と思う。</li>
</ul>
</li>
<li>入力オペランドも同様。
<ul>
<li>C 引数の <code>dwSomeValue</code> の値が入ったレジスタ名で <code>%1</code> が置換される。</li>
</ul>
</li>
<li>最後の <code>"cc"</code> は x86 のフラグレジスタが破壊されることを示す。</li>
</ul>
<p>この入出力オペランド制約では、ループ中で5回呼び出す意味はないと判断され、
コンパイラによってループの外に出される可能性がある。
それを防ぎたいならば、<code>asm volatile</code> とする必要がある (volatile 変数と同じ)。</p>
<p>ただし volatile 変数と同じく、asm volatile をまたいで他の命令が移動される
ことはあり得る (volatile 同士の順番は保存されたはず)。
以下のマニュアルの例では、浮動小数点丸めモードのコントロールレジスタの後に
演算が行われることを保証するために、<code>sum</code> への書き込み依存を追加している。
<code>%0</code> は現れていないため実際には書き込まれないが、コンパイラは
<code>sum = x + y</code> という <code>sum</code> への書き込みを上に移動することはできなくなる
(<code>sum</code> の結果が変わってしまうように見えるため)。</p>
<pre><code class="language-C">asm volatile ("mtfsf 255,%1" : "=X" (sum) : "f" (fpenv));
sum = x + y;
</code></pre>
<p>このように、文法が覚えづらいとか、資料が少なすぎるとか、互換性汎用性が皆無とか、
CPU 固有のオプションがいっぱいあるとかを我慢すれば、C コードとの間の値の受け渡しを
かなりスムーズに実現できる。
素のアセンブリで関数を書くと、呼び出し規約を読みながら引数と返り値がどこに置かれるかで
苦労するし、そもそもインライン化して関数コールのオーバーヘッドを消したいという
ケースも多いかもしれない。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<h2 id="前置き"><a class="header" href="#前置き">前置き</a></h2>
<ul>
<li>Git は元々 Linux kernel の開発のために Linus によって開発された。
<ul>
<li>当時使っていた BitKeeper というプロプライエタリなバージョン管理ソフトで
トラブルがあったため。</li>
<li>プログラムのソースコードのような単純なテキストファイルとの相性が非常によい。</li>
<li>画像動画その他のきらびやかなファイルは歴史データがかさばりよろしくない。
<ul>
<li>git lfs で検索。</li>
</ul>
</li>
</ul>
</li>
<li>コンソール・テキストファイル・テキストエディタ・Linux 至上主義が源流にあるため、
そのあたりは理解しつつ温かい目で見ること。
<ul>
<li>オリジナルの開発者が Linux kernel の開発者だから。</li>
<li>いろいろな人々の長きに渡る努力でいろいろな部分がマシになってきた。</li>
<li>Windows で事故っても怒らない。</li>
</ul>
</li>
<li>Git が主流になってから 10 年以上？変わる気配がないので諦めること。
もしくは、自分で作る。
<ul>
<li>Git の代わりを作るよりは、よりフレンドリーな GUI / Web UI を作る方に
注力するようになったと言えるのかもしれない。</li>
</ul>
</li>
<li>Linux は相当大規模なプロジェクトなので、よほどのプロジェクト規模でない限り
使わないだろうという機能もある。そういうものは気にしなくてよし。</li>
</ul>
<p>プログラムのソースコード以外に相性のよいもの</p>
<ul>
<li>本の原稿</li>
<li>卒業論文</li>
</ul>
<p>この2つに関しては非常にオススメです。
ただし、Git 自体の習得コストがどうしてもネックになることが多いので、
論文執筆のシーズンに入る前に1か月くらい Git で遊んでみることを強くお勧めします。
<strong>シーズンになるとサーバも自分の PC もよりによってこの時期に壊れます。</strong>
ジンクスとかそういうものではなく、その時期にコンピュータを酷使するからです。
手癖のように <code>git push</code> で別の物理マシンとの間でリポジトリごと同期しておくと
トラブル時に非常に速やかに対処できます。
編集履歴が自動で全部記録されていつでも戻せるので大変更の保険もバッチリです。</p>
<h2 id="ヘルプ"><a class="header" href="#ヘルプ">ヘルプ</a></h2>
<pre><code class="language-sh">git help CMD
git CMD --help
</code></pre>
<h2 id="リポジトリ"><a class="header" href="#リポジトリ">リポジトリ</a></h2>
<p>これまでの全ての更新履歴を含むデータが入ったもの。
大雑把に言うと <code>.git/</code> ディレクトリとほぼ同義。
<code>.git/</code> の中身が具体的にどうなっているのか漁って回るタイプの人間が作っているので
そういうものだと思っておくこと。</p>
<p>Git は (他のバージョン管理システムと比較して) <strong>分散型</strong> と呼ばれる。
ローカルマシンにもリモートサーバにも同じようにこれまでの履歴全体を保管する構造に
なっている。
これは最初のコマンドが <code>git clone</code> という名前の通り、リポジトリをサーバから
丸ごとコピーすることからも分かる。
ただし設計上対等とはいえ、サーバ側でよくある使い方とクライアント側でよくある使い方は
存在し、異なる。</p>
<p>(Git 一択になっている現状、知る必要はないが)
分散型でない中央集権型のシステム (CVS, SVN) では、サーバに全ての履歴を保管し、
クライアントは必要なデータのみをサーバからダウンロードするような仕組みになっていた。
ネットワーク速度やクライアントマシンのディスク容量に余裕が出てきたから
可能になったスタイルとも言える。</p>
<h3 id="git-init"><a class="header" href="#git-init">git init</a></h3>
<p>ディレクトリを git リポジトリとして初期化する。
実行後、<code>.git/</code> という名前の隠しディレクトリができている。
この中に全履歴が保存されていく。</p>
<p>実は、あまり使わない…。
大抵の場合、共有サーバ等のリモートのリポジトリを clone して始めることの方が多い。
clone した場合は自動でその clone 元が <code>origin</code> という名前で登録される。</p>
<pre><code class="language-sh">git init --bare
</code></pre>
<p>主にサーバ的に使うコンピュータ上で初期化するためのコマンド。
ワーキングコピー
(作業用に、ある時点のファイルセットを普通に編集できる形で展開したもの)
を作らない。純粋に履歴の保管庫 (push/fetch のため) としてのみ運用する
リポジトリとして初期化する。
ベア (裸の) リポジトリと呼ばれる。</p>
<h3 id="git-clone"><a class="header" href="#git-clone">git clone</a></h3>
<p>いつもの。</p>
<pre><code class="language-sh">git clone &lt;repo&gt; [&lt;dir&gt;]
</code></pre>
<p>リポジトリのアドレスの最後の部分が自動的にディレクトリ名として使われるが、
後ろに追加で指定するとディレクトリ名を好きなものに変えることができる。</p>
<pre><code class="language-sh">$ git remote -v
origin  https://github.com/yappy/grimoire.git (fetch)
origin  https://github.com/yappy/grimoire.git (push)
</code></pre>
<p>clone 元のアドレスが自動的に <code>origin</code> という名前の remote として登録される。
手動で登録するのは面倒なので clone 推奨。
ただし <code>origin</code> というデフォルトネームはリモート関連のコマンドが何をやっているのか
理解するためには覚えておいた方がよい。</p>
<pre><code class="language-sh">$ git branch -a
  gh-pages
* main
  remotes/origin/HEAD -&gt; origin/main
  remotes/origin/gh-pages
  remotes/origin/main
</code></pre>
<p>リモートトラッキングブランチも <code>remotes/(リモート名)/(ブランチ名)</code> という名前で
自動的に作られる。
これは名前の通り、リモートリポジトリの変更を追跡するためのブランチで、
リモートブランチの丸々コピーを表す。
このあたりを知っておくと fetch, push のやっていることが分かりやすい。</p>
<p>昨今のソフトウェアの肥大化は留まることを知らず、プロジェクトによっては
リポジトリが肥大化しており clone にとてつもない時間がかかることがある。
場合によっては昔の全履歴は必要ないということもあるだろうから、
clone には豊富なオプションが用意されている。</p>
<ul>
<li><code>depth=1</code> shallow clone (浅いクローン)
<ul>
<li><del>他は難しくて覚えられない。</del></li>
<li>制限が多く罠だらけの状態になるので最新の状態を閲覧したいだけの時以外は
使わない方がよい。</li>
</ul>
</li>
<li>partial clone
<ul>
<li>ブロブレスクローンとツリーレスクローンがあるらしい。</li>
<li>シャロークローンより制限が緩いようだが、中途半端なのでフルクローンすれば
いいんじゃないかと思う。</li>
<li><del>一晩寝て待っていれば終わるよ。</del></li>
<li><del>豊かなディスク容量とネットワーク帯域でゴリ押すのが現代の
ソフトウェアエンジニアリングだよ</del></li>
</ul>
</li>
</ul>
<h3 id="いつもの新規作成手順"><a class="header" href="#いつもの新規作成手順">いつもの新規作成手順</a></h3>
<ol>
<li>GitHub の web UI でリポジトリを新規作成する。</li>
<li>これは GirHub のサーバ上で <code>mkdir</code> して <code>git init --bare</code> することに相当する。
ついでに README 等を最初のコミットとして入れてくれる。</li>
<li>web UI で見えるアドレスをコピー。</li>
<li>ローカルで <code>git clone &lt;コピーしたアドレス&gt;</code></li>
<li>完了。これだけ！</li>
</ol>
<h2 id="ローカルの作業"><a class="header" href="#ローカルの作業">ローカルの作業</a></h2>
<p>ローカルリポジトリに対して編集を行う方法。</p>
<h3 id="ワークツリーとステージング"><a class="header" href="#ワークツリーとステージング">ワークツリーとステージング</a></h3>
<p><code>--bare</code> でない Git リポジトリのディレクトリには、
リポジトリ内の履歴の今いる時点の内容が、
普通に編集できるディレクトリやファイルの形で展開されている。
これをワークツリーとかワーキングコピーと呼んでいる。</p>
<p>これを書き換えてコミット (履歴の一時点として登録) するわけだが、
その前にコミットに含めたい変更のみを置くための場所がインデックス
(名前が分かりづらい気がする。。) とかステージングエリアなどと呼ばれる場所である。</p>
<p>変更量が多かったり、一度に論理的に複数の変更をしてしまったため
コミットを分けたい場合に便利である。
そうでない場合は面倒なだけだが、多少ショートカットできるオプションもある。</p>
<h3 id="コミットの指定"><a class="header" href="#コミットの指定">コミットの指定</a></h3>
<p>全てのコミットにはハッシュがついており、これを使って特定のコミットを
指定することができる。
このハッシュには SHA-1 が使われており、計算元のデータには Author や Date 等の
文字列も含めているためそれらが少しでも変わると全く違う値になる。
これは全てのコミット間で異なることを前提に組まれているため、
天文学的に運が悪いとシステムが破綻するが気にしなくてよい。
ハッシュはほとんどの場合最初の方だけでも他と被らないので、
一意に判別できるなら最初の6ケタ程度でも認識される。</p>
<pre><code class="language-sh">$ git log
commit 987e4e5a09483b952bac7a0dfcd64970905fe7d9 (HEAD -&gt; main)
Author: yappy &lt;superunyo@yahoo.co.jp&gt;
Date:   Wed Dec 25 01:02:17 2024 +0900

    Install mdbook-mermaid
</code></pre>
<h3 id="git-status"><a class="header" href="#git-status">git status</a></h3>
<p><strong>とにかくこれ。</strong>
ここからやりたくなる操作についてどのようなコマンドを打てばいいかもかなり親切に
教えてくれる。</p>
<pre><code class="language-sh">git status
</code></pre>
<p>例</p>
<pre><code class="language-sh">$ git status
# 現在いるブランチ名
On branch main
# リモートトラッキングブランチとの比較
# 自分の方が1つコミットが多いところにいるので、これをリモートに送りたいなら
# git push でできるよ
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)
# ステージ中の変更
# このまま git commit した時にコミットされる内容
# git restore --staged で戻せるよ
Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)
        modified:   README.md
        modified:   src/SUMMARY.md
        new file:   src/git.md
# ステージされていない変更
# git add でステージできるよ
# git restore で変更を破棄 (現在いるコミットの内容に戻す) できるよ
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
        modified:   src/git.md

</code></pre>
<h3 id="git-diff"><a class="header" href="#git-diff">git diff</a></h3>
<p>コミットと</p>
<h3 id="git-add"><a class="header" href="#git-add">git add</a></h3>
<pre><code class="language-sh">git add &lt;file/dir&gt;
</code></pre>
<ul>
<li>git 管理下のファイルの場合、変更をステージングする。</li>
<li>git 管理下でない場合、ファイルの追加をステージングする。</li>
<li>ディレクトリを指定すると、そのディレクトリ以下の全ファイルに上記を適用する。</li>
</ul>
<p>やっぱりやめたいときは <code>git status</code> を見る。</p>
<pre><code class="language-sh">git add -p &lt;path&gt;
</code></pre>
<p>中級コマンド。
1つのファイル内の差分を部分的にステージする。
Yes/No/もっと細かく分割、で答えていくことで好きな部分だけステージする
(他の部分は別のコミットとする) ことができる。</p>
<h3 id="git-rm"><a class="header" href="#git-rm">git rm</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-1"><a class="header" href="#git-1">Git</a></h1>
<h2 id="git-の内部実装"><a class="header" href="#git-の内部実装">Git の内部実装</a></h2>
<p>Git は他のファイルシステムの上で作られた、ユーザランドファイルシステムの一種である。
<code>git add</code> <code>git commit</code> のようなコマンドはハイレベルな抽象コマンドで、
よりローレベルなファイルシステム操作用のコマンドも存在している。</p>
<h2 id="git-object"><a class="header" href="#git-object">Git Object</a></h2>
<p>それぞれの commit に SHA-1 ハッシュが付与されており、コミットハッシュで
特定のコミットを一意に示すことができるのはよく知られているが、
そのコミットを構成する要素にもまたハッシュが付与されている。
グラフ理論で言うとループのない有向グラフとなる。</p>
<ul>
<li>blob
<ul>
<li>ファイルデータ (ファイル名は含まない)</li>
</ul>
</li>
<li>tree
<ul>
<li>blob と tree (再帰的) からなるディレクトリツリー構造</li>
</ul>
</li>
<li>commit
<ul>
<li>tree とコミット情報からなるディレクトリツリーのスナップショット</li>
</ul>
</li>
<li>tag
<ul>
<li>特定のコミットへの参照</li>
</ul>
</li>
</ul>
<h3 id="blob"><a class="header" href="#blob">blob</a></h3>
<p>リンク構造のリーフノードとなるような末端のオブジェクトで、ファイルの内容を表す。
ファイル名の情報は含まない。
ヘッダのフォーマットはテキスト形式で、<code>blob</code> という文字列、スペース、
ファイルサイズを文字列で、そしてヌル文字 (1 byte のゼロ)で区切って
以下ファイルのバイナリデータが続く。</p>
<p>例: <code>blob 6\0Hello!</code></p>
<p>そしてこのヘッダを含むデータ全体に対して SHA-1 hash を計算する。
SHA (Secure Hash Algorithm) はセキュアなハッシュアルゴリズムだが、
セキュリティというよりはヘッダも含めて 1 byte でも違えば全く異なる値になる点、
出力空間全体にまんべんなくランダムに散らばるように見える点を生かしていると思われる。
SHA-1 は 16 進数で 40 文字になる。</p>
<pre><code class="language-c">hash = sha1("blob 6\0Hello!")
</code></pre>
<p>オブジェクトのハッシュが求まったら、<code>.git/objects</code> に以下のようなパスで保存される。
また、この時 zlib 圧縮 (zip みたいな可逆圧縮) がなされる。
これは blob に限らない。</p>
<p><code>.git/objects/{最初の2文字}/{残りの38文字}</code></p>
<p>ここから以下のようなことが分かる。</p>
<ul>
<li>全く同一の内容 (ファイル名は問わない) のファイルの場合、ヘッダも含めてハッシュ計算の
ソースが完全に一致するため、ハッシュも同一値になる。
<ul>
<li>新たにオブジェクトを保存する必要はなく、されない。</li>
</ul>
</li>
<li>運悪く異なるオブジェクトのハッシュ値が衝突してしまった場合、システムは破綻する。
<ul>
<li>天文学的に低い確率なので無視できる。そういう設計のために SHA-1 を使っている。</li>
<li>ハッシュテーブルで文字列を管理する時のようないい加減なノンセキュアハッシュだと
できやすい・できにくいハッシュ値に偏りがあって衝突しやすくなりそう。</li>
</ul>
</li>
</ul>
<h3 id="tree"><a class="header" href="#tree">tree</a></h3>
<p>例を見た方が早い。</p>
<pre><code class="language-sh">$ git cat-file -p &lt;hash&gt;
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
</code></pre>
<p>実際のバイナリフォーマットは以下のようになっている。</p>
<ul>
<li>"tree"</li>
<li>スペース</li>
<li>サイズを文字列で</li>
<li>NUL</li>
<li>中身...</li>
</ul>
<p>tree の場合、中身のフォーマットは</p>
<ul>
<li><code>[mode] [file/folder name]\0[SHA-1 of referencing blob or tree]</code></li>
</ul>
<p>らしい。
hash はバイナリで、固定長のため次のエントリへの区切り文字は不要らしい。
これがファイルかディレクトリかはそのハッシュからオブジェクトを引けば分かる。
また、ファイル名、ディレクトリ名の情報はここで付与される。</p>
<p>タイプを文字列で、スペース、サイズ、NULL 文字、サイズで指定された大きさの中身、
というのが git オブジェクトの共通のヘッダ及び全体の仕様となっている。
ヘッダも含めた全体に SHA-1 ハッシュ関数を適用し、その値から
<code>.git/objects/</code> 以下のパスを決定し保管されるのも同様である。</p>
<p>tree は blob または tree を任意の個数持つ、という再帰データ構造になっているので、
ファイルディレクトリツリーのある時点でのスナップショットを表すことになる。
ファイル or ディレクトリ名の変更で tree オブジェクトハッシュは変わるし、
ファイル内容 (blob) が変わるとそのハッシュが変わるので、それが書かれた
tree オブジェクトのハッシュも変わることになる (別オブジェクトとなる)。</p>
<h3 id="commit"><a class="header" href="#commit">commit</a></h3>
<p>tree によってある時点のディレクトリツリーのスナップショットが作れれば
コミットオブジェクトはとても簡単で、コミットとはある時点での
ファイルディレクトリツリーのスナップショットを指すのだから、
ある1つの tree オブジェクトへのリンクが本体である。
それにコミットメッセージや作者、コミット日時などのメタ情報を含めたものが
コミットオブジェクトである。</p>
<pre><code class="language-sh">$ git cat-file -p &lt;hash&gt;
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700

first commit
</code></pre>
<p>これも実際はヌル文字を含むフォーマットであり先頭に共通のヘッダが付与され、
全体に SHA-1 を適用してハッシュが求められる。
これが <code>git log</code> でいつも目にする "コミットハッシュ" である。</p>
<p>マージコミットは少し特殊で、親コミットが2つになることがある。</p>
<h3 id="tag"><a class="header" href="#tag">tag</a></h3>
<p><code>git tag -a</code> のアノテートタグは、tag というタイプの git object が作られる。
したがってタグにハッシュもつく。</p>
<pre><code class="language-sh">git cat-file -p &lt;hash&gt;
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag
</code></pre>
<p>コミットへの参照が本体で、他にタグ名、作者、日時、タグメッセージなどが
含まれている。
ちなみにタグはコミット以外の任意の git object に対して作ることができるらしい。</p>
<p>軽量タグは単なるコミットへの参照であり、git object は作られない。</p>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>Git の設計は上層と下層に分かれている。</p>
<p>下層は、ヘッダとコンテンツから SHA-1 ハッシュを計算し、ハッシュをキーとした
リポジトリデータベースへ格納、また逆にハッシュからコンテンツを引くことのできる、
(カーネルファイルシステム上に構築された) ユーザランドファイルシステムになっている。</p>
<p>上層は、そのハッシュベースのファイルシステムをうまく使って
バージョンコントロールシステムを構築している。</p>
<p>Linux カーネル開発者作らしいというか、ある種の素養がないとひらめくのは難しいが、
一度理解してしまえばシンプルで一貫した設計で、
他にも応用の効きそうな興味深い設計である。</p>
<p>スナップショットに対応したジャーナリングファイルシステムのような
リッチなファイルシステムについて調べてみるのもよいかもしれない。
(すみません、私は組み込み志向なので勉強不足です)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h1>
<ul>
<li>最初から順に読み進めて読破が狙えるものと、それは普通に無理なものが存在する。</li>
</ul>
<h2 id="データ構造とアルゴリズム"><a class="header" href="#データ構造とアルゴリズム">データ構造とアルゴリズム</a></h2>
<ul>
<li>アルゴリズムイントロダクション
<ul>
<li>Introduction to Algorithms: アルゴリズム入門 (MIT 基準)</li>
<li>アルゴリズム専門の研究者になるなら入門だから…。</li>
<li>数学的厳密性が重視されており、ややマイナーなアルゴリズムも掲載。
その代わり圧倒的な分量を持つ。</li>
</ul>
</li>
<li>もう1冊軽いものがあるとよいと思うが、色々ありすぎて何がよさそうか謎。。</li>
</ul>
<h2 id="形式言語理論"><a class="header" href="#形式言語理論">形式言語理論</a></h2>
<ul>
<li>オートマトン言語理論 計算論</li>
</ul>
<h2 id="オペレーティングシステム"><a class="header" href="#オペレーティングシステム">オペレーティングシステム</a></h2>
<p>cf. コンピュータアーキテクチャ</p>
<ul>
<li>
<p>Operating System Concepts</p>
<ul>
<li>恐竜本。</li>
<li>他にもいくつか案はあるが、多少の実践に立ち入った本よりは下記をやった方がよいのかも。</li>
</ul>
</li>
<li>
<p>6.1810: Operating System Engineering</p>
<ul>
<li>MIT の OS 実践授業</li>
<li>xv6 (最初期の UNIX の ANSI C 再実装) を使う。ソースがコンパクトで綺麗で明快だが
OS のエッセンスは揃っている。</li>
<li>GitHub の risc-v 版ソースコードを手元に用意しながら授業ページの pdf を読めば
あっという間に一流の人形遣いになれそう。</li>
<li>アセンブラ、リンカスクリプト、スタートアップルーチン</li>
<li>昔は x86 だったので、苦行を積みたい場合はそちら。</li>
</ul>
</li>
<li>
<p>30日でできる! OS自作入門</p>
</li>
<li>
<p>ゼロからのOS自作入門</p>
<ul>
<li>BIOS or UEFI およびク〇すぎる x86 のブートアップに正面から向き合うことができる。</li>
<li>理論的な面は弱め。他にないタイプの本であることに間違いはない。</li>
</ul>
</li>
</ul>
<h2 id="コンピュータアーキテクチャ"><a class="header" href="#コンピュータアーキテクチャ">コンピュータアーキテクチャ</a></h2>
<p>cf. ディジタル回路、オペレーティングシステム</p>
<ul>
<li>
<p>コンピュータの構成と設計</p>
<ul>
<li>パタヘネ。これは文句なくまずはこの一冊(日本語版は一冊ではない)でOK。</li>
<li>Amazon 検索だと誤って古い版を買ってしまいやすいので注意(一敗)。</li>
</ul>
</li>
<li>
<p>コンピュータアーキテクチャ 定量的アプローチ</p>
<ul>
<li>ヘネパタ。むずかしい。</li>
</ul>
</li>
<li>
<p>CPU の創りかた</p>
<ul>
<li>20年経っても色あせない名著</li>
<li><del>読んだことがない</del></li>
</ul>
</li>
</ul>
<h2 id="コンパイラ"><a class="header" href="#コンパイラ">コンパイラ</a></h2>
<p>cf. オートマトン、正規表現</p>
<ul>
<li>コンパイラ―原理・技法・ツール
<ul>
<li>ドラゴンブック。</li>
<li>教科書として使うのは微妙な気もするけどだったら何がいいのかはよくわからない。</li>
</ul>
</li>
<li>低レイヤを知りたい人のためのCコンパイラ作成入門 <a href="https://www.sigbus.info/compilerbook">https://www.sigbus.info/compilerbook</a>
<ul>
<li>C で C コンパイラを作る完全実践型。C セルフホスト RTA が流行っているらしい(???)</li>
<li>コンパイラについては構文解析は理論的な面が大きいが、
出力にアセンブラや機械語のローレイヤの知識が必要なのがアレ。</li>
</ul>
</li>
</ul>
<h2 id="データベース"><a class="header" href="#データベース">データベース</a></h2>
<p>わかんない。。</p>
<h2 id="プログラミング"><a class="header" href="#プログラミング">プログラミング</a></h2>
<ul>
<li>コンパイラ言語</li>
<li>スクリプト言語</li>
<li>関数型言語</li>
</ul>
<p>を最低1つずつ習得するのがよいとされている(要出典)。</p>
<h2 id="関数型言語-という訳ではない"><a class="header" href="#関数型言語-という訳ではない">関数型言語 (という訳ではない)</a></h2>
<ul>
<li>SICP
<ul>
<li>最近はやめてしまったらしい。何で LISP を学んだらいいのかわからない。</li>
</ul>
</li>
<li>型システム入門 −プログラミング言語と型の理論− (TAPL)
<ul>
<li>これも関数型言語の本ではないが</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="交流"><a class="header" href="#交流">交流</a></h1>
<h2 id="実数"><a class="header" href="#実数">実数</a></h2>
<p>交流電源電圧 (単位は V: ボルト) を</p>
<p>\[
V(t) = V_0 \sin (\omega t + \phi)
\]</p>
<p>とする。</p>
<ul>
<li>\( V_0 \): 振幅 (V)
<ul>
<li>三角関数は -1 から 1 の間を振動するので、電圧は
\( - V_0 \leq V(t) \leq V_0 \) の間を振動する。</li>
</ul>
</li>
<li>\( \omega \): 角周波数 (rad/s)
<ul>
<li>時刻を角度に変換する比例定数。振動の速さを表す。</li>
</ul>
</li>
<li>\( t \): 時刻 (s)</li>
<li>\( \phi \): 初期位相 (rad)
<ul>
<li>三角関数の中身 (rad) のことを位相と呼ぶ。
位相は時間的な位置を角度の単位で表したもの。</li>
<li>初期位相は \( t = 0 \) のときの位相のこと。</li>
</ul>
</li>
</ul>
<p>角周波数と周期、周波数について。
どれか1つが決まれば他もすべて自動的に決まる。</p>
<ul>
<li>\( \omega \): 角周波数 (rad/s)
<ul>
<li>1秒間に位相が何 rad 進むか。</li>
</ul>
</li>
<li>\( T \): 周期 (T)
<ul>
<li>振動が1回にかかる時間。</li>
</ul>
</li>
<li>\( f \): 周波数 (Hz = 1/s)
<ul>
<li>1秒に何回振動するか。</li>
</ul>
</li>
</ul>
<p>三角関数は位相が 360 度進むと一周する。
角速度 \( \omega \) (rad/s) で角度 \( 2 \pi \) (rad) を進むのにかかる時間が
周期 \( T \) (s) である。</p>
<p>\[
\begin{eqnarray}
\omega T = 2 \pi \\
T = \frac{ 2 \pi }{ \omega } \\
\end{eqnarray}
\]</p>
<p>周期と周波数は逆数の関係にある。</p>
<p>\[
\begin{eqnarray}
f &amp;=&amp; \frac{ 1 }{ T } \\
T &amp;=&amp; \frac{ 1 }{ f } \\
\end{eqnarray}
\]</p>
<p>以上で困ることはないはずだが、以下の表式は他の式から導くのではなく覚えておくと便利。</p>
<p>\[
\begin{eqnarray}
\omega &amp;=&amp; 2 \pi f \\
V(t) &amp;=&amp; V_0 \sin (2 \pi f t + \phi) \\
\end{eqnarray}
\]</p>
<h3 id="抵抗"><a class="header" href="#抵抗">抵抗</a></h3>
<p>\[
\begin{eqnarray}
V(t) &amp;=&amp; R I(t) \\
I(t) &amp;=&amp; \frac{ 1 }{ R } V(t) \\
&amp;=&amp; \frac{ 1 }{ R } V_0 \sin (\omega t + \phi) \\
\end{eqnarray}
\]</p>
<h3 id="コンデンサ"><a class="header" href="#コンデンサ">コンデンサ</a></h3>
<p>\[
Q(t) = C V(t)
\]</p>
<p>コンデンサに流れ込む電流 (A = C/s) がコンデンサに蓄えられた電荷 (C) の
単位時間あたりの増加量であるので、両辺を時間で微分して、</p>
<p>\[
\begin{eqnarray}
I(t) &amp;=&amp; \frac{ d }{ dt } Q(t) \\
&amp;=&amp; C V'(t) \\
&amp;=&amp; \omega C V_0 \cos (\omega t + \phi) \\
&amp;=&amp; \omega C V_0 \sin (\omega t  +\phi + 90^{\circ}) \\
\end{eqnarray}
\]</p>
<ul>
<li>電圧に比べて電流は位相は 90 度(1/4 周期) 進んでいる。</li>
<li>位相差は実数では取り扱いにくいので、一旦無視して電圧と電流の振幅の比から
「抵抗のようなもの」を考える。これを (容量性) <strong>リアクタンス</strong> という。
電圧/電流なので単位はオーム。</li>
</ul>
<p>\[
\begin{eqnarray}
I_0 &amp;=&amp; \omega C V_0  \\
V_0 &amp;=&amp; X_C I_0 \\
X_C &amp;=&amp; \frac{ V_0 }{ I_0 } \\
&amp;=&amp; \frac{ 1 }{\omega C} \\
\end{eqnarray}
\]</p>
<ul>
<li>静電容量が大きいほどリアクタンスは小さい。
コンデンサの容量が大きいほど大きな電流が流れる。</li>
<li>角周波数が大きいほどリアクタンスは小さい。
頻繁に充放電の方向が切り替わると、大きな電流が流れる。</li>
</ul>
<h3 id="コイル"><a class="header" href="#コイル">コイル</a></h3>
<p>\[
V(t) = L \frac{ d }{ dt } I(t)
\]
(符号に注意。キルヒホッフの法則で電圧の上昇下降の和が 0 になる式を立てる時に
コイルの起電力がマイナスになる。)</p>
<p>両辺を t で積分して (積分定数の処理が面倒だがどうせ 0 になる)</p>
<p>\[
\begin{eqnarray}
\int V(t) dt &amp;=&amp; L I(t) \\
I(t) &amp;=&amp; \frac{ 1 }{ L } \int V(t) dt \\
&amp;=&amp; - \frac{ 1 }{ \omega L } V_0 \cos (\omega t + \phi) \\
&amp;=&amp; \frac{ 1 }{ \omega L } V_0 \sin (\omega t + \phi - 90^{\circ}) \\
\end{eqnarray}
\]</p>
<ul>
<li>電圧に比べて電流は位相は 90 度(1/4 周期) 遅れている。</li>
<li>コンデンサと同様に位相差は一旦無視して電圧と電流の振幅の比から
「抵抗のようなもの」を考える。これを (誘導性) <strong>リアクタンス</strong> という。
電圧/電流なので単位はオーム。</li>
</ul>
<p>\[
\begin{eqnarray}
I_0 &amp;=&amp; \frac{ 1 }{ \omega L } V_0  \\
V_0 &amp;=&amp; X_L I_0 \\
X_L &amp;=&amp; \frac{ V_0 }{ I_0 } \\
&amp;=&amp; \omega L \\
\end{eqnarray}
\]</p>
<ul>
<li>自己インダクタンスが大きいほどリアクタンスは大きい。
コイルが強いほど、電流は流れにくくなる。</li>
<li>角周波数が大きいほどリアクタンスは大きい。
頻繁に電圧の正負が切り替わって電流を激しく変化させようとすると、
コイルに激しく抵抗されて電流は小さくなる。</li>
</ul>
<h3 id="rlc-直列回路"><a class="header" href="#rlc-直列回路">RLC 直列回路</a></h3>
<p>交流電源にコイルやコンデンサを1つだけつないだ場合は微分または積分を1回行うだけで
何とかなったが、実際の回路はそれをいくつもつなげるわけで、
対応できるかちょっと不安になってくる。
RLC を直列に並べたときの電圧のつり合いを考えると、</p>
<p>\[
R I(t) + L \frac{ d }{ dt } I(t) + \frac{ 1 }{ C } Q(t) = V(t)
\]</p>
<p>両辺 t で微分して Q を I に揃える。</p>
<p>\[
\begin{eqnarray}
R I'(t) + L I''(t) + \frac{ 1 }{ C } I(t) &amp;=&amp; V'(t) \\
R I'(t) + L I''(t) + \frac{ 1 }{ C } I(t) &amp;=&amp;
\omega V_0 \cos (\omega t + \phi) \\
I'' + \frac{R}{L} I' + \frac{1}{LC} I &amp;=&amp;
\frac{\omega V_0}{L} \cos (\omega t + \phi) \\
\end{eqnarray}
\]</p>
<p>これは I(t) に関する二階線形微分方程式 (非斉次, 非同次) になっている。
実際にやると結構大変だが、解き方は確立されているので
その通りにやれば解けるといえば解ける。</p>
<ul>
<li>右辺を 0 とした同次形を解く。</li>
<li>非同次形の特解を何か1つ気合で見つける。</li>
<li>上記2つを足したものが非同次形の一般解となる。</li>
</ul>
<p>とにかく右辺が 0 になっていないところが苦しい (0 ならば比較的簡単に解ける) ので、
右辺を消すことを考える。
ここで、苦しいもののなんとか特解を1つでも見つけることができれば、
辺々引き算することで右辺を 0 にすることができる。</p>
<p>同次形は特性方程式を解き、2つの指数関数の線形和が一般解になる。
問題は非同次形の特解を求めるところで、今回はここが三角関数になっているケースであるので、
攻略法を調べて特解は \( A \sin \omega t + B \cos \omega t \) という形に
なるらしいという情報からいい感じに係数を決定してやる。</p>
<p>このように、解けると言えば解けるのだがはっきり言って結構大変なため、
もっと簡単な方法を導入する。</p>
<h3 id="補足-rlc-並列回路"><a class="header" href="#補足-rlc-並列回路">(補足) RLC 並列回路</a></h3>
<p>R, L, C が並列につないだ場合、それぞれの両端に同じ交流電圧
\( V(t) \) がかかるので、
別個に電流を計算して最後に足し合わせればよい。
あまり問題として出てこないのはこのように簡単なためである。</p>
<h2 id="複素数"><a class="header" href="#複素数">複素数</a></h2>
<p>事情により、まず sin を cos にしておく。
sin も cos も同じ形の関数で位相が 1/4 周期ずれているだけなので、
この差は初期位相 \( \phi \) の部分に吸収されるため、どちらでもよい。</p>
<p>\[
V(t) = V_0 \cos (\omega t + \phi)
\]</p>
<p>t-V グラフのまま考えるのは筋が悪いので、2次元平面での等速円運動を考える。</p>
<p>\[
\begin{eqnarray}
V(t) = x(t) &amp;=&amp; V_0 \cos (\omega t + \phi) \\
y(t) &amp;=&amp; V_0 \sin (\omega t + \phi) \\
r &amp;=&amp; V_0 \\
\theta(t) &amp;=&amp; \omega t + \phi \\
\end{eqnarray}
\]</p>
<p>y 座標を追加することで角速度一定の円運動としてとらえられるようにした。
すると、円運動なので極座標で考えると半径が定数関数、角度が一次関数になり、
より簡単に表せるようになる。
ここから y 座標を無視したもの (x 軸への射影) が電源電圧であると考える。</p>
<p>y 座標は極座標へ持ち込むために人為的に追加したものであるので、
逆に言えば何でもいいということにもなる。
極座標と言えば複素平面なので、y 軸を虚軸とし、また、オイラーの公式により
三角関数による複素平面での xy 直交座標表示と指数関数による極座標表示が等しい。
虚数単位として i を使ってしまうと電流と混同する危険があるので、次の文字である
j を使う。</p>
<p>\[
\begin{eqnarray}
\dot{V}(t) &amp;=&amp; x(t) + j y(t) \\
&amp;=&amp; r e^{ j \theta(t) } \\
x(t) &amp;=&amp; V_0 \cos (\omega t + \phi) \\
y(t) &amp;=&amp; V_0 \sin (\omega t + \phi) \\
r &amp;=&amp; V_0 \\
\theta(t) &amp;=&amp; \omega t + \phi \\
\end{eqnarray}
\]</p>
<p>電圧に y 座標を虚部として追加した <strong>複素電圧</strong> を導入した。
上部のドットは複素数であることを示す印である(逆にドットの無いものは実数である)。
この虚部は複素平面上での等速円運動ととらえるために計算の都合で追加したもので、
現実に観測される電圧電流とは関係がない。</p>
<p>具体的に代入すると</p>
<p>\[
\begin{eqnarray}
\dot{V}(t) &amp;=&amp; V_0 e^{ j (\omega t + \phi) } \\
&amp;=&amp; V_0 e^{ j \phi } e^{ j \omega t } \\
&amp;=&amp; \dot{V}_0 e^{ j \omega t } \\
\dot{V}_0 &amp;=&amp; V_0 e^{ j \phi } \\
\end{eqnarray}
\]</p>
<p>\( \dot{V}_0 \) には振幅と初期位相の情報を1つの複素数に埋め込んでいる。
長さが振幅 \( V_0 \) に等しい棒を、
初期位相 \( \phi \) の角度だけ回転させたものになっている。
それを \( \omega t \) だけさらに回転させたものが時刻 t における複素電圧である。</p>
<p>複素電圧から実際に観測される電圧を取り出すには、y 座標 (虚部) を無視して
x 座標 (実部) だけを取り出せばよい。</p>
<p>\[
\begin{eqnarray}
V(t) = x(t) &amp;=&amp; \mathrm{Re} (\dot{V}(t)) \\
&amp;=&amp; V_0 \cos (\omega t + \phi) \\
\end{eqnarray}
\]</p>
<h3 id="コンデンサ-複素数"><a class="header" href="#コンデンサ-複素数">コンデンサ (複素数)</a></h3>
<p>コンデンサの電流を求める式の電圧を複素電圧に置き換えてみる。
複素数の微分の実数倍だから、電流も複素数になる。
実際に観測される電流はこの実部である。
オイラーの功績により複素数の微分積分は実数の場合と全く同じ法則が成り立ち、
指数関数の微分なので三角関数より楽である。</p>
<p>\[
\begin{eqnarray}
\dot{I}(t) &amp;=&amp; C \dot{V}'(t) \\
&amp;=&amp; C (\dot{V}_0 e^{ j \omega t })' \\
&amp;=&amp; j \omega C \dot{V}_0 e^{ j \omega t } \\
&amp;=&amp; j \omega C \dot{V}(t) \\
\end{eqnarray}
\]</p>
<p>複素電圧と複素電流が (虚数単位が含まれることを受け入れれば)
定数倍の関係になっているので、
その比から「抵抗っぽいもの」を求めることができる。
複素数を複素数で割るので複素数になる。</p>
<p>\[
\begin{eqnarray}
\dot{Z}_C &amp;=&amp; \frac{ \dot{V}(t) }{ \dot{I}(t) } \\
&amp;=&amp; \frac{1}{ j \omega C } \\
\end{eqnarray}
\]</p>
<p>これを (複素) <strong>インピーダンス</strong> と呼ぶ。</p>
<p>\[
\begin{eqnarray}
\dot{V}(t) &amp;=&amp; \dot{Z}_C \dot{I}(t) \\
\dot{I}(t) &amp;=&amp; \frac{1}{ \dot{Z}_C } \dot{V}(t) \\
\end{eqnarray}
\]</p>
<p>電流と電圧を複素化し、その比も抵抗を複素化したもの (インピーダンス) とみなすことで、
オームの法則の自然な拡張となっている。
インピーダンスの極形式での絶対値と偏角をみると、</p>
<p>\[
\begin{eqnarray}
|\dot{Z}_C| &amp;=&amp; \frac{1}{ \omega C } \\
\arg (\dot{Z}_C) &amp;=&amp; -90^{\circ}
\end{eqnarray}
\]</p>
<ul>
<li>複素数の掛け算は絶対値の掛け算と偏角の足し算</li>
<li>複素数の割り算は絶対値の割り算と偏角の引き算</li>
</ul>
<p>\[
\begin{eqnarray}
r_1 e^{ j \theta_1 } \cdot r_2 e^{ j \theta_2 }
&amp;=&amp; (r_1 r_2 ) e^{ j (\theta_1 + \theta_2) } \\
&amp;=&amp; r_3 e^{ j \theta_3 } \\
r_3 &amp;=&amp; r_1 r_2 \\
\theta_3 &amp;=&amp; \theta_1 + \theta_2 \\
\end{eqnarray}
\]</p>
<p>だから、</p>
<ul>
<li>インピーダンスの絶対値は電圧と電流の振幅の比を表す。
<ul>
<li>これはリアクタンスに等しい。</li>
</ul>
</li>
<li>インピーダンスの偏角は電圧と電流の位相の差を表す。</li>
</ul>
<p>実数では位相差の話は難しいので諦めて振幅の比のみをリアクタンスとして求めたが、
複素インピーダンスには振幅の比に加えて位相差の情報も同時に含めることに成功している。</p>
<p>電圧から電流を求めるためにはインピーダンスを掛けるのではなくインピーダンスで
割らなければならないことに注意して、</p>
<ul>
<li>角周波数や静電容量が大きいと電流の振幅はそれに比例して大きくなる。</li>
<li>電流の位相は 90 度早まる。</li>
</ul>
<p>ことが分かる。
これは実数の範囲で微積で求めた結果と一致する。</p>
<h3 id="コイル-複素数"><a class="header" href="#コイル-複素数">コイル (複素数)</a></h3>
<p>\[
\begin{eqnarray}
L \dot{I}'(t) &amp;=&amp; \dot{V}(t) \\
L \dot{I}(t) &amp;=&amp; \int \dot{V}(t) dt \\
\dot{I}(t) &amp;=&amp; \frac{1}{L} \int \dot{V}_0 e^{ j \omega t } dt \\
&amp;=&amp; \frac{1}{ j \omega L } \dot{V}_0 e^{ j \omega t } \\
&amp;=&amp; \frac{1}{ j \omega L } \dot{V}(t) \\
\end{eqnarray}
\]</p>
<p>コイルも同じく電圧と電流が複素数の世界で比例関係になり、</p>
<p>\[
\begin{eqnarray}
\dot{Z}_L &amp;=&amp; \frac{ \dot{V}(t) }{ \dot{I}(t) } \\
&amp;=&amp; j \omega L \\
\end{eqnarray}
\]</p>
<p>\[
\begin{eqnarray}
|\dot{Z}_L| &amp;=&amp; \omega L \\
\arg (\dot{Z}_L) &amp;=&amp; +90^{\circ}
\end{eqnarray}
\]</p>
<h3 id="rlc-直列回路-複素数"><a class="header" href="#rlc-直列回路-複素数">RLC 直列回路 (複素数)</a></h3>
<p>複素電圧、電流、インピーダンスを導入した状態で、もう一度 RLC 直列回路を考えてみよう。</p>
<ul>
<li>RLC 各素子の両端にかかる電圧はよく分からない。
ただしそれら3つをすべて合計すると電源電圧となる。
電源電圧は既知の振幅・周波数・初期位相の三角関数、に虚部を加えて複素化したもの。</li>
<li>RLC 各素子に流れる電流は同一である。それを求めたい。</li>
<li>RLC 各素子の両端にかかる電圧と電流はその素子の複素インピーダンスを用いて
オームの法則のようなものが成り立っている。</li>
</ul>
<p>\[
\begin{eqnarray}
\dot{V}(t) &amp;=&amp; \dot{V}_0 e^{ j \omega t }
= \dot{V}_R(t) + \dot{V}_L(t) + \dot{V}_C(t) \\
\dot{V}_R(t) &amp;=&amp; R \dot{I}(t) \\
\dot{V}_L(t) &amp;=&amp; j \omega L \dot{I}(t) \\
\dot{V}_C(t) &amp;=&amp; \frac{1}{ j \omega C } \dot{I}(t) \\
\end{eqnarray}
\]</p>
<p>よって</p>
<p>\[
\begin{eqnarray}
R \dot{I}(t) + j \omega L \dot{I}(t) + \frac{1}{ j \omega C } \dot{I}(t)
&amp;=&amp; \dot{V}_0 e^{ j \omega t } \\
(R + j \omega L + \frac{1}{ j \omega C }) \dot{I}(t)
&amp;=&amp; \dot{V}_0 e^{ j \omega t } \\
\dot{Z} \dot{I}(t) &amp;=&amp; \dot{V}_0 e^{ j \omega t } \\
\end{eqnarray}
\]</p>
<p>\[
\begin{eqnarray}
\dot{Z} &amp;=&amp; R + j \omega L + \frac{1}{ j \omega C } \\
&amp;=&amp; R + j (\omega L - \frac{1}{ \omega C }) \\
\end{eqnarray}
\]</p>
<p>抵抗が直列に並んでいるとき、その抵抗値の和を合成抵抗として置き換えられたように、
インピーダンスが直列に並んでいるときは、その和を <strong>合成インピーダンス</strong> として
置き換えることができる。
オームの法則の形を全く変えずに各パラメータを複素化しただけなので、
計算が複素数同士の演算になること以外は <strong>オームの法則と全く同じ</strong> 法則が成り立つ。
RLC を並列に接続した場合でも、並列な合成抵抗の式が成り立つ。
直列と並列が複雑に絡み合っても合成抵抗の公式を繰り返し適用していくだけで
合成インピーダンスを求めることができる。
合成インピーダンスには振幅の比だけではなく、位相のずれの情報も入っている。</p>
<p>合成インピーダンスが求まったら複素電源電圧をそのインピーダンスで割ったものが
複素電流である。
実際に流れる電流値を取り出したいならば、虚部を捨てて実部のみ取り出せば完了である。</p>
<p>\[
\begin{eqnarray}
\dot{Z} &amp;=&amp; R + j \omega L - j \frac{1}{ \omega C } \\
\dot{I}(t) &amp;=&amp; \frac{ \dot{V}_0 }{ \dot{Z} } e^{ j \omega t } \\
I(t) &amp;=&amp; \mathrm{Re} (\dot{I}(t)) \\
&amp;=&amp; I_0 \sin (\omega t + \phi_I) \\
I_0 &amp;=&amp; \frac{ |\dot{V}_0| }{ |\dot{Z}| } \\
\phi_I &amp;=&amp; \arg \frac{ \dot{V}_0 }{ \dot{Z} }
\end{eqnarray}
\]</p>
<p>このように、複素数の四則演算ができれば微分方程式を解かずとも、オームの法則から
電流を求めるのと同じ要領で電流がどのような波か分かってしまう。</p>
<h3 id="rlc-直列共振回路"><a class="header" href="#rlc-直列共振回路">RLC 直列共振回路</a></h3>
<p>合成インピーダンスの式をよく見ると、</p>
<p>\[
\begin{eqnarray}
\dot{Z} = R + j \omega L + \frac{1}{ j \omega C }\\
\end{eqnarray}
\]</p>
<p>R, L, C を固定しても角周波数が変わるとインピーダンスの値が変わることが分かる。
\( \omega \longrightarrow +0 \) および
\( \omega \longrightarrow \infty \) の極限を考えると、
どちらの場合でも片方は 0 に収束するが、もう片方が無限大に発散してしまう。
つまり、周波数がほぼ 0 の直流のような電圧に対してはコンデンサは
(過渡現象を無視すると) 電流をほとんど通さず、周波数が非常に高い電圧に対しては
コイルがほとんど電流を通さない。</p>
<p>では周波数が程よい値だった場合どうなるだろうか。
\( R, L, C \gt 0 \) それぞれのインピーダンスを複素平面で考えると、</p>
<ul>
<li>R: 実数なので常に原点から <strong>右向き</strong>。角周波数によって変化しない。</li>
<li>L: 虚数成分しか持たず、常に原点から <strong>上向き</strong>。
<ul>
<li>\( \omega \longrightarrow 0 \):
絶対値は 0 に近づく。</li>
<li>\( \omega \longrightarrow \infty \)
絶対値は無限大に発散する。</li>
</ul>
</li>
<li>C: 虚数成分しか持たず、常に原点から <strong>下向き</strong>。
<ul>
<li>\( \omega \longrightarrow 0 \):
絶対値は無限大に発散する。</li>
<li>\( \omega \longrightarrow \infty \)
絶対値は 0 に近づく。</li>
</ul>
</li>
</ul>
<p>複素数の足し算は2次元ベクトルの足し算と同じなので、まず上下方向のベクトルだけ
足し算すると、</p>
<p>\[
j (\omega L - \frac{1}{ \omega C }) \\
\]</p>
<p>これは引き算の結果が正のとき上向き、負のとき下向きのベクトルである。
そして \( \omega \) 以外を固定して \( \omega \) を 0 から無限大の間で
動かしてやると、各項は単調増加および単調減少なので、どこかで1回絶対値が等しくなり
結果が 0 になる \( \omega \) が存在する。それは</p>
<p>\[
\begin{eqnarray}
\omega L &amp;=&amp; \frac{1}{ \omega C } \\
\omega^2 LC &amp;=&amp; 1 \\
\omega^2 &amp;=&amp; \frac{1}{LC} \\
\omega &amp;=&amp; \frac{1}{ \sqrt{LC} } \\
T &amp;=&amp; \frac{ 2 \pi }{ \omega } \\
f &amp;=&amp; \frac{ \omega }{ 2 \pi } \\
&amp;=&amp; \frac{1}{ 2 \pi \sqrt{LC} } \\
\end{eqnarray}
\]</p>
<p>最後、角周波数を周波数に直したが、これが <strong>共振周波数</strong> で、
この周波数の電圧に対して電流の振幅が最も大きくなる。
そして高校物理ではこの共振周波数の最終結果を覚えることになっている。なんでやねん。</p>
<p>そして最後に R (右向きのベクトル) と足し合わせるが、
真上または真下またはゼロベクトルと右向きのベクトルを足すので、
結果の絶対値 (ベクトルの長さ) が最小となるのはコイルとコンデンサのインピーダンスの和が
ゼロになるときである。
このとき RLC の合成インピーダンスは R (実数) に等しくなる。</p>
<h2 id="消費電力"><a class="header" href="#消費電力">消費電力</a></h2>
<ul>
<li>P (W=J/s): 1秒あたりに回路から失われる (電気から他の形になる) エネルギー。消費電力。
電気抵抗では主に熱エネルギーに変わって放出される。</li>
<li>I (A=C/s): 1秒あたりに流れる電気量。電流。</li>
<li>V (V=J/C): +1C が電位が高いところから低いところへ移動したときに得るエネルギー。
すなわち失う位置エネルギー。
正確には位置エネルギーではないことの方が多い気がするが、混同してしまっても
そこまで問題にはならない。
電位差という言い方は正確さに欠くことがあるが、電圧とか言っておけばごまかせる。</li>
</ul>
<p>\[
\begin{eqnarray}
P(t) = I(t) V(t)
\end{eqnarray}
\]</p>
<p>最初は公式を丸覚えさせられる気もするが、定義や単位を見ながら考えれば割と
当然のことを言っているだけの式である。</p>
<h3 id="消費電力-実数"><a class="header" href="#消費電力-実数">消費電力 (実数)</a></h3>
<p>交流の場合は電圧と電流が時間変化によって絶えず変化しているが、
瞬間的な電圧と電流を掛ければその瞬間の消費電力になる。
これに微小時間を掛けて出てくる微小エネルギーを足し合わせる (積分する) ことによって
ある時間内に消費されるエネルギーを計算することができる。</p>
<p>\[
\begin{eqnarray}
V(t) &amp;=&amp; V_0 \sin \omega t \\
I(t) &amp;=&amp; \frac{ V_0 }{ R } \sin \omega t \\
P(t) &amp;=&amp; I(t) V(t) \\
&amp;=&amp; \frac{ V_0^2 }{ R } \sin^2 \omega t \\
\end{eqnarray}
\]</p>
<p>しかし例えば 50 Hz の交流電圧の周期は 0.02 s であり、
実用上欲しいのはそんな短い時間中での細かい消費電力変化の詳細ではなく、
何分・何時間・何日動かし続けたときにどのくらいのエネルギーが消費されるかという方である。
そのためには1周期分の消費エネルギーを時間で割った平均の消費電力を求めれば十分で、</p>
<p>\[
\begin{eqnarray}
P(t) &amp;=&amp; \frac{ V_0^2 }{ R } \sin^2 \omega t \\
\bar{P} &amp;=&amp; \frac{1}{T} \int_0^T P(t) dt \\
&amp;=&amp; \frac{1}{T} \int_0^T \frac{ V_0^2 }{ R } \sin^2 \omega t dt \\
&amp;=&amp; \frac{1}{T} \frac{ V_0^2 }{ R } \int_0^T \sin^2 \omega t dt \\
\end{eqnarray}
\]</p>
<p>結局 sin の2乗を (その sin の) 1周期で積分するとどうなるかということに帰着した。
積の積分は難しいので何らかの手を打つ必要があるが、三角関数同士の積は加法定理を
右から左に使うと角度の和に変換して次数を下げることができる。</p>
<p>\[
\begin{eqnarray}
\sin (\alpha \pm \beta) = \sin \alpha \cos \beta \pm \cos \alpha \sin \beta \\
\cos (\alpha \pm \beta) = \cos \alpha \cos \beta \mp \sin \alpha \sin \beta \\
\end{eqnarray}
\]</p>
<ul>
<li>積の内訳
<ul>
<li>sin 同士、または cos 同士の場合: cos の加法定理を使う。</li>
<li>sin と cos の積の場合: sin の加法定理を使う。</li>
</ul>
</li>
<li>角度の内訳
<ul>
<li>角度が同じ場合:
\( \beta = \alpha \) とし、角度のプラスを取る。(倍角・半角の公式)</li>
<li>角度が異なる場合:
複号を変えた式を2つ用意し、欲しい積のみが残るよう辺々足し算 or 引き算する。
(積和・和積の公式)</li>
</ul>
</li>
</ul>
<p>角度の等しい sin 同士の積を三角関数の1乗に直したいので、
cos の加法定理を同じ角度同士の和に適用する。
\( \sin^2 \alpha + \cos^2 \beta = 1 \) よりこの2つは相互に変換できるので
今欲しい sin 同士の積のみの形にする
(cos の2乗が欲しいならそちらのみの形にすればよい)。</p>
<p>\[
\begin{eqnarray}
\cos (\alpha + \alpha) &amp;=&amp; \cos^2 \alpha - \sin^2 \alpha \\
\cos 2 \alpha &amp;=&amp; (1 - \sin^2 \alpha) - \sin^2 \alpha \\
&amp;=&amp; 1 - 2 \sin^2 \alpha \\
\end{eqnarray}
\]</p>
<h3 id="消費電力-複素数"><a class="header" href="#消費電力-複素数">消費電力 (複素数)</a></h3>
<p>TODO: 内積は複素共役を取って掛ける</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="フィボナッチ数列"><a class="header" href="#フィボナッチ数列">フィボナッチ数列</a></h1>
<p>\[
\begin{eqnarray}
F_{n+2} &amp;=&amp; F_{n+1} + F_{n} \\
F_1 &amp;=&amp; 1 \\
F_2 &amp;=&amp; 1 \\
\end{eqnarray}
\]</p>
<h2 id="例-1"><a class="header" href="#例-1">例</a></h2>
<p>\[
\begin{eqnarray}
F_0 &amp;=&amp; 0 \\
F_1 &amp;=&amp; 1 \\
F_2 &amp;=&amp; 1 \\
F_3 &amp;=&amp; 2 \\
F_4 &amp;=&amp; 3 \\
F_5 &amp;=&amp; 5 \\
F_6 &amp;=&amp; 8 \\
F_7 &amp;=&amp; 13 \\
F_8 &amp;=&amp; 21 \\
F_9 &amp;=&amp; 34 \\
F_{10} &amp;=&amp; 55 \\
\end{eqnarray}
\]</p>
<p>小学校の足し算ができれば遊べるフレンドリーな問題です。</p>
<h3 id="補足"><a class="header" href="#補足">補足</a></h3>
<p>ちょっと考えると、別に n を増やす方向にしか使えないわけではなく、
連続する3項のうち2項が分かっていて「抜け」が1つだけなら他の2項から求めることができる。
したがって、マイナスの方向にも進んでいくこともできる。
これにより \( F_0 = 0 \) とできるし、0番目から始めてもよい。</p>
<h2 id="隣接三項間漸化式"><a class="header" href="#隣接三項間漸化式">隣接三項間漸化式</a></h2>
<p>\[ 1 \cdot F_{n+2} = 1 \cdot F_{n+1} + 1 \cdot F_{n} \]</p>
<p>この漸化式はよく見ると全係数が1の線形和の形になっており、
高校数学に出てくる隣接三項間漸化式である。
なので例の謎解法を用いて解く (一般解を得る) ことができる。</p>
<p>漸化式から謎ルールにより特性方程式は</p>
<p>\[
\begin{eqnarray}
F_{n+2} &amp;=&amp; F_{n+1} + F_{n} \\
x^2 &amp;=&amp; x + 1 \\
x^2 &amp;-&amp; x - 1 = 0
\end{eqnarray} \]</p>
<p>で、これは幸いにも実数解が2つ得られて、</p>
<p>\[ x = \frac{ 1 \pm \sqrt{5} }{2} \]</p>
<p>通常高校生に解かせる問題はここがきれいな整数になるよう調整されているが、
係数が全部1できれいだと思わせておいて、このような無理数になってしまう。
何度も書くのはツラいので、文字で置き換えることとする。
( \( \alpha \) は <strong>黄金比</strong> と呼ばれる数で、人が「きれいに」感じる比率である。
自然界にも多く存在する。)</p>
<p>\[
\begin{eqnarray}
\alpha &amp;=&amp; \dfrac{ 1 + \sqrt{5} }{2} \\
\beta  &amp;=&amp; \dfrac{ 1 - \sqrt{5} }{2}
\end{eqnarray}
\]</p>
<p>この特性方程式の解を使うと謎解法により、漸化式は以下の2通りに変形できる。</p>
<p>\[
\begin{eqnarray}
F_{n+2} - \alpha F_{n+1} &amp;=&amp; \beta  ( F_{n+1} - \alpha F_{n} ) \\
F_{n+2} - \beta  F_{n+1} &amp;=&amp; \alpha ( F_{n+1} - \beta  F_{n} )
\end{eqnarray}
\]</p>
<p>どこからこんな変形が出てくるのか本当に意味が分からないと思われる (意味は後述) が、
展開して検算してみると確かにどちらも元の式に戻る。
これらの式は以下のような新しい数列を考えると、単純な等比数列になることを示している。
公比は順に \( \beta, \alpha \) である。</p>
<p>\[
\begin{eqnarray}
a_n = F_{n+1} - \alpha F_n \\
b_n = F_{n+1} - \beta  F_n
\end{eqnarray}
\]</p>
<p>等比数列は簡単に一般項を表現できて、n 番目の値は 1 番目の値に公比を n - 1 回
かけたものだから、以下の一般項を得る。</p>
<p>\[
\begin{eqnarray}
a_n &amp;=&amp; a_1 \cdot \beta ^{n-1} \\
b_n &amp;=&amp; b_1 \cdot \alpha^{n-1} \\
a_1 &amp;=&amp; F_2 - \alpha F_1 = 1 - \alpha \\
&amp;=&amp; \beta \\
b_1 &amp;=&amp; F_2 - \beta  F_1 = 1 - \beta \\
&amp;=&amp; \alpha
\end{eqnarray}
\]</p>
<p>\( \alpha + \beta \) を計算してみると1になることから、初項は1文字できれいに
表すことができる。
それ以外に関しては高校数学のテンプレ解法をなぞっただけである。
まとめるとやたらきれいになる (うまく文字で置き換えたからでもあるが)。</p>
<p>\[
\begin{eqnarray}
a_n &amp;=&amp; \beta  ^ n \\
b_n &amp;=&amp; \alpha ^ n
\end{eqnarray}
\]</p>
<p>新しく作った数列をもとのフィボナッチ数列に戻してやると</p>
<p>\[
\begin{eqnarray}
F_{n+1} - \alpha F_n &amp;=&amp; \beta  ^ n \\
F_{n+1} - \beta  F_n &amp;=&amp; \alpha ^ n
\end{eqnarray}
\]</p>
<p>辺々引き算すると \( F_{n+1} \) を消去できる。</p>
<p>\[ ( \alpha - \beta ) F_n = \alpha ^ n - \beta ^ n　\]</p>
<p>これはもう解けていて、フィボナッチ数列の一般項を求められている。
\( \alpha, \beta\) を代入すると</p>
<p>\[
\begin{eqnarray}
\alpha &amp;=&amp; \frac{ 1 + \sqrt 5 }{2} , \quad
\beta  = \frac{ 1 - \sqrt 5 }{2} \\
F_n &amp;=&amp; \frac{ 1 }{ \alpha - \beta } ( \alpha ^ n - \beta ^ n ) \\
F_n &amp;=&amp; \frac{ 1 }{ \sqrt 5 } \left \{
\left ( \frac{ 1 + \sqrt{5} }{2} \right ) ^ n -
\left ( \frac{ 1 - \sqrt{5} }{2} \right ) ^ n
\right \}
\end{eqnarray}
\]</p>
<p>とても整数になるようには見えないが、フィボナッチ数列の定義より明らかに
全ての整数 \( n \) について \( F_n \) は整数である。
実際、\( n \) に具体的な整数を代入してみると魔法のように整数になる。</p>
<h2 id="なんやねんこれは"><a class="header" href="#なんやねんこれは">なんやねんこれは</a></h2>
<p>フィボナッチ数列の問題というよりは、隣接三項間漸化式の解き方だけを高校生に教えており
なぜこれで解けるのか意味が分からないところが問題である。</p>
<p>実は線形和になっている隣接三項間漸化式は <strong>二階の線形微分方程式(同次形)</strong> と
解き方がそっくりである。そっくりどころか、数学的にしっかり解析すると
<strong>同型</strong> であるとまで言えてしまう。</p>
<p>漸化式の \( a_{n+1} - a_n \) のことを <strong>差分</strong> とも呼び、
これに関する方程式を <strong>差分方程式</strong> とも呼ぶ。
\(y\) を \(x\) の関数とするとき、\( y' = \frac{ dy }{ dx } \) を
<strong>微分</strong> と呼び、これに関する方程式を <strong>微分方程式</strong> と呼ぶ。
差分方程式は、連続的な関数に関する微分方程式を、離散的な関数 (数列) で考える
バージョンだととらえることができる。</p>
<p>フィボナッチ数列に <em>そっくりな</em> 微分方程式は以下のようになる。</p>
<p>\[
\begin{eqnarray}
y'' = y' + y \\
y'' - y' - y = 0
\end{eqnarray}
\]</p>
<p>このような形の方程式は解き方が確立されている。
高校では取り扱わないのだが、同型だと言った通り、隣接三項間漸化式の解き方という扱いで
日本の高校生は実質的に解かされている…。</p>
<p>しかしながら高校物理における単振動は運動方程式がこの形の微分方程式であり、
(実数)解が三角関数になるという結果を暗記させられる。
これもどうかという気はするが、微分方程式は解くのは (非常に) 難しいが
解の候補が正しいかは実際に微分して代入して成り立つか調べるだけで確認できるため、
ギリギリ許せるかもしれない。
しかし \( t \) の係数である角周波数 \( \omega \) が質量とばね定数から
決定できて振動の周期や (周波数) を確定できるというのは、
さすがに微積分なしという建前の上でかなりの無茶をやっている気がする。。</p>
<p>\[
\begin{eqnarray}
m \frac{ d^2 x }{ d t^2 } = - k x \\
m x'' + kx = 0 \\
x'' + \frac{k}{m} x = 0 \\
x'' + \omega ^2 x = 0 \\
\cdots \\
x(t) = A \sin ( \omega t + \phi )\\
\omega = \sqrt{\frac{k}{m}}
\end{eqnarray}
\]</p>
<p>とにかく、階数 (微分回数) に関わらず線形微分方程式の解き方は確立されていて、
それは以下の考察による。</p>
<p>\( f(x), g(x) \) が解のとき、</p>
<ul>
<li>定数倍 \( c f(x) \) も解である。</li>
<li>\( f(x) + g(x) \) も解である。</li>
</ul>
<p>これは以下の微分の性質を線形微分方程式に代入すれば確認できる。</p>
<ul>
<li>\( \{ c f (x) \}' = c f'(x) \)</li>
<li>\( \{ f(x) + g(x) \}' = f'(x) + g'(x) \)</li>
</ul>
<p>これを踏まえた解法は以下のようになる。</p>
<ol>
<li>なんでもいいから頑張って特殊解 (特解) を2つ (二階の場合) 探す。
ただし定数倍の関係になっているものは除く(<strong>一次独立</strong>という)。</li>
<li>その2つを \( f(x), g(x) \) とすると、
\( C f(x) \) や \( D g(x) \) も解だし、
解の和もまた解である。</li>
<li>\( y = C f(x) + D g(x) \) が解全体 (一般解) となる (C, D は任意定数)。</li>
<li><strong>初期条件</strong> を1つ与えられると、任意定数を1つ決定することができる。
二階の場合は2つ出てくるので、任意性を消すためには初期条件が2つ必要である。
これはフィボナッチ数列で言えば最初の2項が必要であることに相当する。</li>
</ol>
<p>これの他に解が無いことはどう証明するのか？などと考えてしまいそうになるが、
とんでもなく難しい話になるので気にしてはいけない (数学科へ GO)。
2回の微分を行っているので、任意定数 (積分定数みたいなもの) が2つ出てくれば
全部の解を覆いつくせていると考えておけば OK ではないが OK。</p>
<p>問題は一般解でなくていいとはいえ特殊解をどうやって探すかだが、</p>
<p>\[
y'' - y' - y = 0
\]</p>
<p>この式をよく見ると y を微分したりもう一回微分したりしても、元の y の定数倍にしか
ならないようなものしか解にならなそうに見える。
微分 <strong>方程式</strong> と名前がついているが、イコールが成り立つ x を求めるのではなく、
これが x についての <strong>恒等式</strong> (x に何を入れても成り立つ) になるような y が
どのような x の関数なのかを求める問題である。</p>
<p>解を指数関数と仮定して微分も行うと、</p>
<p>\[
\begin{eqnarray}
y   &amp;=&amp; e ^ { \lambda x } \\
y'  &amp;=&amp;  \lambda e ^ { \lambda x } = \lambda y \\
y'' &amp;=&amp; \lambda ^ 2 e ^ { \lambda x } = \lambda ^ 2 y \\
\end{eqnarray}
\]</p>
<p>となり、このまま線形微分方程式に代入してやる。</p>
<p>\[
\begin{eqnarray}
y'' - y' - y = 0 \\
\lambda ^ 2 y - \lambda y - y = 0 \\
( \lambda ^ 2 - \lambda - 1 ) y = 0 \\
( \lambda ^ 2 - \lambda - 1 ) e ^ { \lambda x } = 0 \\
\lambda ^ 2 - \lambda - 1 = 0 \quad ( \because e^{\lambda x} \neq 0) \\
\end{eqnarray}
\]</p>
<p>最後の式がまさに例の高校数学謎解法でも使われる <strong>特性方程式</strong> である。
差分方程式 (漸化式) も微分方程式と同じようなもの (どころか同型) なので
<strong>同じ用語を使う</strong>。</p>
<p>二階の場合は二次方程式になるので、その解は</p>
<ul>
<li>異なる2つの実数解</li>
<li>実数の重解</li>
<li>異なる2つの虚数解</li>
</ul>
<p>のいずれかになる。
二つの異なる解があれば \( y = e ^ { \lambda_1 x}, y = e ^ { \lambda_2 x}\)
という一次独立な (定数倍でない) 二解が得られるので楽だが、
重解の場合はちょっと (結構？) 困る。
しかし定数変化法で何とかなることは確立しているので安心してよい。</p>
<p>フィボナッチ数列の係数の場合は2つの実数解が得られるので、</p>
<p>\[
\begin{eqnarray}
y = C e^{ \alpha x } + D e^{ \beta x}
\end{eqnarray}
\]</p>
<p>これが一般解である (C, D は任意定数)。</p>
<p>ちなみに単振動の場合は</p>
<p>\[
\begin{eqnarray}
\lambda^2 + \omega^2 = 0 \\
\lambda^2 = - \omega^2 \\
\lambda = \pm i \omega
\end{eqnarray}
\]</p>
<p>二つの虚解となる。
複素指数関数は複素数であるので、任意定数も複素数として</p>
<p>\[
x(t) = C e^{ i \omega t } + D e^{ - i \omega t }
\]</p>
<p>ただしこれだと x 座標が複素数になってしまうので、実数になるような条件で
絞ってやる必要がある。
オイラーの公式</p>
<p>\[
e^{ i \theta } = \cos \theta + i \sin \theta
\]</p>
<p>を使って指数関数の極形式を三角関数の直交座標に直し、虚部が 0 になるよう調整すれば、
2つの任意の複素数、つまり4つの任意の実数が、2つの任意の実数に制約される。</p>
<p>\[
x(t) = A \sin{ \omega t } + B \cos{ \omega t }
\]</p>
<p>ここまでやっておいてなんだが、システマティックに複素指数関数の一般解から頑張らなくても、
運動方程式をガン見すればお互いに定数倍でない実数関数の特解2つは見つかる。</p>
<p>\[
\begin{eqnarray}
x(t) = A \sin{ \omega t } \\
x(t) = B \cos{ \omega t }
\end{eqnarray}
\]</p>
<p>別に sin と cos でないといけないわけではないが、(sin, -sin) のように
位相が 180 度ずれると-1 倍となってしまい、一次独立ではなくなってしまうため注意。</p>
<p>周波数の同じ三角関数の和は、同じ周波数の三角関数になる。
高校数学だと三角関数の合成という名目で加法定理の逆として教えられるが、
これも謎の決まったテクニックとして教えられておりよろしくない。
とにかく任意の振幅で位相差が 0 度や 180 度でない三角関数同士を合成すると、
任意の振幅かつ任意の位相差の三角関数になる。
sin と cos に限定するなら高校数学の三角関数の合成で証明できる。</p>
<p>\[
\begin{eqnarray}
x(t) = C \sin{ (\omega t + D) }
\end{eqnarray}
\]</p>
<p>文字が被ってしまったが実数任意定数を置き直した。
微分して代入すればきちんと解になっていることが分かる。</p>
<p>三角関数の中身の時刻 t の係数 \( \omega \) が分かれば、
三角関数は 360 度 ( \( 2 \pi \) rad ) で一周するので、
振動の一周にかかる時間 (周期) はここまでくれば、</p>
<p>\[
\begin{eqnarray}
T &amp;=&amp; \frac{ 2 \pi }{ \omega }
&amp;=&amp; 2 \pi \sqrt{ \frac{m}{k} }
\end{eqnarray}
\]</p>
<p>と簡単に求められる。
が、これを微積なしの建前で暗記させるのはさすがに無茶が過ぎるようにも感じる。</p>
<h3 id="解の補足"><a class="header" href="#解の補足">解の補足</a></h3>
<p>特解を探す際に指数関数が解になりそう、と言ったが、よく考えると (よく考えなくても)
指数関数ではなく 0 という x によらない定数関数も条件を満たすことが分かる。
よってこれも立派な微分方程式の解である
(ただし、<strong>自明な解</strong> と呼ばれることもある…)。</p>
<p>\[
\begin{eqnarray}
y'' - y' - y = 0 \\
y(x) = 0
\end{eqnarray}
\]</p>
<p>ただ、これは特解の定数倍を考えたときに</p>
<p>\[
\begin{eqnarray}
y = C e^{ \lambda t }
\end{eqnarray}
\]</p>
<p>ここで \( C = 0 \) とすると、これは x に関する指数関数ではなく
定数関数になってしまうが、ちょうど自明な解と一致している。
なので、指数関数にならない \( C \neq 0 \) という断りを入れずに
任意の実数とすることで解を合成している。
このあたり、テキストによっては軽く触れられていることもあれば、
完全に省略されてしまっている場合もある。</p>
<p>自然科学 (物理学) は適当にやってみて、何か説明のつかない自然現象が起きてから
よく見直してみたら数学的にまずいことをやっていたのを発見し、
ならばそれを直す、というようなアプローチを取りがちなので、要はいい加減である。
たまに (よく) 物理学者と数学者で衝突が発生しているが、生温かい目で見守っておけばよい。</p>
<h2 id="漸化式を線形微分方程式のように解いてみる"><a class="header" href="#漸化式を線形微分方程式のように解いてみる">漸化式を線形微分方程式のように解いてみる</a></h2>
<p>\[
\begin{eqnarray}
F_{n+2} &amp;=&amp; F_{n+1} + F_{n} \\
F_1 &amp;=&amp; 1 \\
F_2 &amp;=&amp; 1 \\
\end{eqnarray}
\]</p>
<ul>
<li>初めの式は、項間の関係を示している。これは二階線形微分方程式 (同次) に対応し、
ここから任意定数2つを含む一般解が得られる。</li>
<li>残りの式は初期条件である。2つあるのですべての任意定数を消去し、
解を1つに確定させることができる。</li>
</ul>
<p>これに線形微分方程式の解法を適用してみよう。</p>
<ul>
<li>まず、漸化式をよく見ると、ある数列がこの漸化式を満たす場合、それを定数倍した
数列もまた解になることが分かる。</li>
<li>また、ある2つの数列がこの漸化式を満たす場合、それを足したものもまた解になる
ことが分かる。ただし、2つの式が定数倍の場合は第一の性質で事足りるので除く。</li>
<li>証明は難しいが、2つの数列と2つの任意定数で解空間全体を覆いつくすことができる。</li>
</ul>
<p>となれば、まずは初期条件を無視し、まだ一般解でなくていいので漸化式を満たすような
特解を2つ、なんとかして見つけられないかという話になる。
微分方程式のときは微分すると元の関数の定数倍になるような関数ならよさそう、
そしてそれは指数関数が該当していた。
次の項が今の項の定数倍となるような数列が思い当たる。
そしてそれは等比数列である。
また、その定数倍も条件を満たすが、一般性はまだいらないので初項は適当でよい。
初項を公比と同じにしておけば式が簡単になる。</p>
<p>\[
\begin{eqnarray}
y' &amp;=&amp; \lambda y \\
y &amp;=&amp; e^{ \lambda x } \\
F_{n+1} &amp;=&amp; r F_n \\
F_n &amp;=&amp; r^n \\
\end{eqnarray}
\]</p>
<p>では等比数列を漸化式に代入すると</p>
<p>\[
\begin{eqnarray}
F_{n+2} - F_{n+1} - F_n &amp;=&amp; 0 \\
F_n &amp;=&amp; r^n \\
r^2 \cdot r^n - r \cdot r^n - r^n &amp;=&amp; 0 \\
(r^2 - r - 1) r^n &amp;=&amp; 0 \\
r^2 - r - 1 &amp;=&amp; 0 \quad (\because r^n \neq 0)
\end{eqnarray}
\]</p>
<p>これは <strong>特性方程式である</strong> 。
この解 \( \alpha, \beta \) を底とした等比数列 (指数関数) は漸化式を満たす。
また、その定数倍も漸化式を満たし、解である。
また、2つの解を足し合わせたものも解である。
(特性方程式の解が整数にならないと検算が大変なので、適当な高校数学の問題で確認するとよい)</p>
<p>\[
\begin{eqnarray}
F_{n+2} - F_{n+1} - F_n = 0 \\
F_n = \alpha^n, \ \beta^n \\
F_n = C \cdot \alpha^n, \ D \cdot \beta^n \\
F_n = C \cdot \alpha^n + D \cdot \beta^n \\
\end{eqnarray}
\]</p>
<p>これがフィボナッチ数列から初期条件を取り除いた一般解である。
ここから一般性を取り除くには初期条件が2つ必要で、</p>
<p>\[
\begin{eqnarray}
F_n &amp;=&amp; C \cdot \alpha^n + D \cdot \beta^n \\
F_0 &amp;=&amp; 0 = C + D \\
F_1 &amp;=&amp; 1 = \alpha C + \beta D
\end{eqnarray}
\]</p>
<p>C と D の式が2つあるのでそれぞれ決定できる。</p>
<p>\[
\begin{eqnarray}
D &amp;=&amp; -C \\
(\alpha - \beta) C &amp;=&amp; 1 \\
C &amp;=&amp; \frac{1}{ \alpha - \beta } \\
D &amp;=&amp; - \frac{1}{ \alpha - \beta } \\
F_n &amp;=&amp; \dfrac{ 1 }{ \alpha - \beta } ( \alpha ^ n - \beta ^ n ) \\
F_n &amp;=&amp; \dfrac{ 1 }{ \sqrt 5 } \left \{
\left ( \dfrac{ 1 + \sqrt{5} }{2} \right ) ^ n -
\left ( \dfrac{ 1 - \sqrt{5} }{2} \right ) ^ n
\right \}
\end{eqnarray}
\]</p>
<p>高校数学の謎解法と全く同じ解が得られた。</p>
<p>謎解法と言っても、当然この解構造を意識して作られたもので、
解空間全体を網羅できているか明らかでない (示せるが超大変) という弱点を
うまく解消している。
その代わり、特性方程式がどこから出てきたアイデアなのかが全く示されておらず、
テクニックの丸暗記状態となってしまっている。
そもそも高校数学では微分方程式はまったくやらないか、ほんの少し基本的な問題だけ、
という状態なのに、二階線形微分方程式と同型な問題をこっそり解かせているということであり、
どうかと思う。</p>
<h2 id="線形代数からのアプローチ"><a class="header" href="#線形代数からのアプローチ">線形代数からのアプローチ</a></h2>
<p>まず漸化式が線形和の形になっているし、線形微分方程式の解も線形代数の考え方が
ベースになっている。
特解を基底とした2次元空間 (指数関数をベクトルのように見なしている) が
解空間となっている。
そもそも線形でない微分方程式などほとんどの場合とてもじゃないが解けやしない。</p>
<p>というわけで、漸化式が線形なのをヒントに、線形代数の言葉で書き直してみる。
線形和はベクトルの内積だと考えて、</p>
<p>\[
\begin{eqnarray}
F_{n+2} &amp;=&amp; F_{n+1} + F_n \\
F_{n+2} &amp;=&amp;
\begin{pmatrix} 1 &amp; 1 \end{pmatrix}
\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix}
\end{eqnarray}
\]</p>
<p>(行ベクトルを上の方によせたいが、やり方が分からない。ごめんなさい。)</p>
<p>これで例えば \( (F_2, F_1) \) というベクトルに \( (1, 1) \) というベクトルを
かける (内積) と、\( F_3 \) になる、と考えることができる。
しかし次にやりたいのは \( F_4 \) を求めることで、そのためには
\( (F_3, F_2) \) に係数ベクトルをかける必要がある。
つまり \( F_3 \) だけでなく \( F_2 \) も同時に欲しいのだが、
\( (F_2, F_1) \) から \( F_2 \) への変換はとても簡単で、\( (1, 0)\) を
かければよい。
一般化すると</p>
<p>\[
\begin{eqnarray}
F_{n+1} &amp;=&amp; 1 \cdot F_{n+1} + 0 \cdot F_n \\
F_{n+1} &amp;=&amp;
\begin{pmatrix} 1 &amp; 0 \end{pmatrix}
\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix}
\end{eqnarray}
\]</p>
<p>2つの変換を合体させて、ベクトル \( (F_{n+1}, F_n) \) を
ベクトル \( (F_{n+2}, F_{n+1}) \) に <strong>行列</strong> をかけて変換すると
考えることができる。</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} F_{n+2} \\ F_{n+1} \end{pmatrix} =
\begin{pmatrix} 1 &amp;&amp; 1 \\ 1 &amp;&amp; 0 \end{pmatrix}
\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix}
\end{eqnarray}
\]</p>
<p>つまり、この行列 \( \begin{pmatrix} 1 &amp;&amp; 1 \\ 1 &amp;&amp; 0 \end{pmatrix} \) は、
フィボナッチ数列の隣り合う2項からなるベクトルを、1つ隣の2項からなるベクトルへ
一次変換するものだと考えることができる。
またこの式は、スカラーの等比数列からベクトルの等比数列への
自然な拡張とみなすことができる。公比にあたるものは行列となっている。</p>
<p>行列を1回かけると数列の添え字が1つ増えることから、</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} F_{n+1} \\ F_{n} \end{pmatrix} =
\begin{pmatrix} 1 &amp;&amp; 1 \\ 1 &amp;&amp; 0 \end{pmatrix} ^n
\begin{pmatrix} F_1 \\ F_0 \end{pmatrix}
\end{eqnarray}
\]</p>
<p>と一般に表せる。
ここで律儀にベクトルに行列を左からかける、という操作を n 回行う必要はない。
行列のかけ算は左右を入れ替えてはいけないが、どちらから先に計算するかは変えてもよい。
一次変換の一次変換はまた一次変換である、ということで、それが行列の積の計算規則でもある。
要は行列の n 乗の部分だけ先に積を計算できれば、初項ベクトルにそれを左からかけるだけで
一般解とできそうである。</p>
<p>さて、\( \begin{pmatrix} 1 &amp;&amp; 1 \\ 1 &amp;&amp; 0 \end{pmatrix} ^n \) を
計算できそうか、という話になったが、別の解法により答えは大体分かっており、
あまり簡単には表せない気がする。
試しに2乗や3乗を計算してみても、各要素にフィボナッチ数列のようなものが
現れるだけ (当たり前) で、これを眺めていてもフィボナッチ数列を眺めて
直接一般項を出そうとするのと話は変わらない。</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} 1 &amp;&amp; 1 \\ 1 &amp;&amp; 0 \end{pmatrix}
\begin{pmatrix} 1 &amp;&amp; 1 \\ 1 &amp;&amp; 0 \end{pmatrix} =
\begin{pmatrix} 2 &amp;&amp; 1 \\ 1 &amp;&amp; 1 \end{pmatrix} \\
\begin{pmatrix} 2 &amp;&amp; 1 \\ 1 &amp;&amp; 1 \end{pmatrix}
\begin{pmatrix} 1 &amp;&amp; 1 \\ 1 &amp;&amp; 0 \end{pmatrix} =
\begin{pmatrix} 3 &amp;&amp; 2 \\ 2 &amp;&amp; 1 \end{pmatrix} \\
\begin{pmatrix} 3 &amp;&amp; 2 \\ 2 &amp;&amp; 1 \end{pmatrix}
\begin{pmatrix} 1 &amp;&amp; 1 \\ 1 &amp;&amp; 0 \end{pmatrix} =
\begin{pmatrix} 5 &amp;&amp; 3 \\ 3 &amp;&amp; 2 \end{pmatrix} \\
\end{eqnarray}
\]</p>
<p>行列の n 乗を簡単に求められるようにする方法として、線形代数の授業内容に
大抵入っている <strong>対角化</strong> という手法が有効である。
対角行列のべき乗は</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix}
\begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix} =
\begin{pmatrix} \alpha^2 &amp; 0 \\ 0 &amp; \beta^2 \end{pmatrix} \\
\begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix} ^n =
\begin{pmatrix} \alpha^n &amp; 0 \\ 0 &amp; \beta^n \end{pmatrix} \\
\end{eqnarray}
\]</p>
<p>という風に非常に簡単に計算できる。
そもそも対角行列がどういうものかというと、</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix}
\begin{pmatrix} x \\ y \end{pmatrix} =
\begin{pmatrix} \alpha x \\ \beta y \end{pmatrix} \\
\end{eqnarray}
\]</p>
<p>x と y をそれぞれ単純に定数倍するような行列のことである
(拡大縮小を表すので 3D グラフィクスではスケーリング行列と呼ばれることもある)。
もちろんフィボナッチ数列の前進行列はこのような都合のいい形をしていないので、
なんとかしてこの形に持ち込めないかを考えてみる。</p>
<h3 id="固有値と固有ベクトル"><a class="header" href="#固有値と固有ベクトル">固有値と固有ベクトル</a></h3>
<p>さて、ある行列が与えられたとき、ある方向のベクトルにその行列をかけたときに
ベクトルの方向が変わらず単にスカラー定数倍になる場合がある。
その方向ベクトルを <strong>固有ベクトル</strong> といい、その倍率を <strong>固有値</strong> と呼ぶ。
名前の通り、その行列の性質を表す非常に重要な方向や倍率である。
この単なる定数倍というところが今の課題にうまく使えそうな気がする。
線形代数の授業ではよく分からないままとりあえず求め方を訓練させられるので、
とりあえずフィボナッチ数列の行列の固有ベクトルと固有値を求めてみよう。
求め方はシステム化されていて、あるベクトルに与えられた行列をかけたら
単なるベクトルのスカラー倍になったという条件から、</p>
<p>\[
\begin{eqnarray}
A \boldsymbol{v} &amp;=&amp; \lambda \boldsymbol{v} \\
A \boldsymbol{v} &amp;=&amp; \lambda E \boldsymbol{v} \\
(A - \lambda E) \boldsymbol{v} &amp;=&amp; \boldsymbol{0} \\
\left (
\begin{pmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{pmatrix} -
\begin{pmatrix} \lambda &amp; 0 \\ 0 &amp; \lambda \end{pmatrix}
\right)
\boldsymbol{v} &amp;=&amp; \boldsymbol{0} \\
\begin{pmatrix} 1 - \lambda &amp; 1 \\ 1 &amp; - \lambda \end{pmatrix}
\boldsymbol{v} &amp;=&amp; \boldsymbol{0} \\
\end{eqnarray}
\]</p>
<p>ここで \( \boldsymbol{v} \) で括りたかったが、行列とスカラーは直接足し算引き算が
できないので、単位行列を補って行列同士の減算に書き換えるテクニックを使った。</p>
<p>左辺の行列に逆行列が存在すると仮定すると、両辺に左からその逆行列をかけることができ、
\( \boldsymbol{v} = \boldsymbol{0} \) という解のみになってしまう。
今固有ベクトルとして欲しいのは方向ベクトルであり、方向のないゼロベクトルは
不適である (固有ベクトルの定義式を満たしはするが、固有ベクトルの定義に含めない)。
つまり、(ゼロでない) 固有ベクトルが存在するならば、
この行列は正則でないという必要条件が得られる。
行列が正則であるということの必要十分条件は非常によく研究されており、
その中の「行列式がゼロならば正則ではない (逆も成り立つ)」という条件を使うと</p>
<p>\[
\begin{eqnarray}
\begin{vmatrix} 1 - \lambda &amp; 1 \\ 1 &amp; - \lambda \end{vmatrix} = 0 \\
(1 - \lambda)(- \lambda) - 1 \cdot 1 = 0 \\
\lambda^2 - \lambda - 1 = 0
\end{eqnarray}
\]</p>
<p>これは2次方程式であり、この解が固有値となる (本当は十分性を確認しなければならないが、
結論から言うと固有値になる)。
このように固有値を解に持つ多項式を <strong>固有方程式</strong> と呼ぶ。
一般に n 次正方行列の固有方程式は n 次方程式になり、複素数の範囲かつ重解を別個に
カウントすれば、解は n 個ある。
今回は 2x2 行列なので 2 次方程式になっている。
形が完全に特性方程式と同じになっていることから、解も同じで</p>
<p>\[
\begin{eqnarray}
\lambda^2 - \lambda - 1 = 0 \\
(\lambda - \alpha)(\lambda - \beta) = 0 \\
\lambda^2 - (\alpha + \beta) \lambda - \alpha \beta = 0 \\
\alpha, \beta = \frac{ 1 \pm \sqrt 5 }{2} \\
\alpha + \beta = 1 \\
\alpha \beta = -1 \\
\end{eqnarray}
\]</p>
<p>つまりフィボナッチ数列を表す行列の固有値は \( \alpha, \beta \) の2つである。
\( \lambda = \alpha \) を代入し、行列がランク落ちしていること
(連立一次方程式として見たときに実質的に同じ式が2つ並んでいること。
正則でないことと同値。) と、
特性方程式より和が 1 で積が -1 であることに気を付けつつ整理すると</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} 1 - \alpha &amp; 1 \\ 1 &amp; - \alpha \end{pmatrix}
\boldsymbol{v} &amp;=&amp; \boldsymbol{0} \\
\begin{pmatrix} \beta &amp; 1 \\ 1 &amp; \frac{1}{\beta} \end{pmatrix}
\begin{pmatrix} x \\ y \end{pmatrix} &amp;=&amp; \boldsymbol{0} \\
\beta x + y = 0 \\
y = k \Rightarrow x = - \frac{1}{\beta} k = \alpha k \\
\boldsymbol{v} = k \begin{pmatrix} \alpha \\ 1 \end{pmatrix}
\end{eqnarray}
\]</p>
<p>つまり、\( (\alpha, 1) \) に平行なベクトルに行列 A をかけると方向は変わらず、
単に \( \alpha \) 倍になるということである。
固有値 \( \beta \) についても同様に、固有ベクトル \( (\beta, 1) \)
(の定数倍) を得る。</p>
<h3 id="基底"><a class="header" href="#基底">基底</a></h3>
<p>\( (\alpha, 1) \) と \( (\beta, 1) \) という方向をベースに考えると
よいのではないか、というアイデアが得られた。</p>
<p>ここで座標という考え方を改めて見直してみる。</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} x \\ y \end{pmatrix} =
x \begin{pmatrix} 1 \\ 0 \end{pmatrix} +
y \begin{pmatrix} 0 \\ 1 \end{pmatrix}
\end{eqnarray}
\]</p>
<p>式自体はあまりにも当たり前のものになっているが、これは座標 \( (x , y) \) を
\( (1, 0) \) の方向に \( x \) 倍だけ、\( (0, 1) \) の方向に \( y \) 倍だけ
進んだ先のこととする、という気持ちを表している。
この2つのベクトルのことを <strong>基底</strong> といい、すべての長さが1のとき <strong>正規</strong>、
お互いに垂直のとき <strong>直交</strong> をつけて、<strong>正規直交基底</strong> という。
この例は正規直交基底である。</p>
<p>ここでのアイデアは、基底は正規でも直交でもなくても構わないのではないか？
というところにある。
実際、2次元平面を覆いつくすには正規でも直交でもなくてもいいので
<strong>平行でない</strong> (<strong>一時独立</strong>な) ベクトルが2本あれば十分である
(むしろ正確には必要な基底ベクトルの数を <strong>次元</strong> と定義する)。
垂直でない規定による座標系を <strong>斜交座標系</strong> と言ったりする。</p>
<p>例えば A の固有ベクトルは平行ではないので、任意の正規直交基底による座標は</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} x \\ y \end{pmatrix} &amp;=&amp;
x' \begin{pmatrix} \alpha \\ 1 \end{pmatrix} +
y' \begin{pmatrix} \beta  \\ 1 \end{pmatrix} \\
&amp;=&amp;
\begin{pmatrix} \alpha &amp; \beta \\ 1 &amp; 1 \end{pmatrix}
\begin{pmatrix} x' \\ y' \end{pmatrix}
\end{eqnarray}
\]</p>
<p>のように書ける。
これは斜交座標 (x', y') を決めると正規直交座標 (x, y) が一意に決まるという
気持ちを表している。
行列で表せていることから、この <strong>座標変換</strong> は <strong>一次変換</strong> であることが分かる。</p>
<p>さらに、 \( (\alpha, 1), (\beta, 1) \) は平行ではないから
この変換行列は正則で逆行列が存在し、それを両辺に左からかけると</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} \alpha &amp; \beta \\ 1 &amp; 1 \end{pmatrix} ^{-1}
\begin{pmatrix} x \\ y \end{pmatrix} =
\begin{pmatrix} x' \\ y' \end{pmatrix}
\end{eqnarray}
\]</p>
<p>とも表せる。
これは (x, y) から (x', y') への変換も同様に <strong>一次変換</strong> であるということを
表している。</p>
<h3 id="対角化"><a class="header" href="#対角化">対角化</a></h3>
<p>固有値と座標変換 (基底の変換) を組み合わせて考えてみよう。
まず元の正規直交基底による座標を、固有ベクトルを基底とする座標系に変換してやる。</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} x' \\ y' \end{pmatrix} =
\begin{pmatrix} \alpha &amp; \beta \\ 1 &amp; 1 \end{pmatrix} ^{-1}
\begin{pmatrix} x \\ y \end{pmatrix}
\end{eqnarray}
\]</p>
<p>この座標系に対して、フィボナッチ数列の行列 A を左からかけてみる
(スカラー倍に関してはかけ算の左右を交換しても問題ない)。</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} x \\ y \end{pmatrix} &amp;=&amp;
x' \begin{pmatrix} \alpha \\ 1 \end{pmatrix} +
y' \begin{pmatrix} \beta  \\ 1 \end{pmatrix} \\
A \begin{pmatrix} x \\ y \end{pmatrix} &amp;=&amp;
x' A \begin{pmatrix} \alpha \\ 1 \end{pmatrix} +
y' A \begin{pmatrix} \beta  \\ 1 \end{pmatrix} \\
\end{eqnarray}
\]</p>
<p>ここで、基底を固有ベクトルに取ったことが生きてくる。
固有ベクトルとはその方向に行列をかけたら対応する固有値 (スカラー) 倍になるという
ものだったから、行列 A の代わりに固有値倍となって、</p>
<p>\[
\begin{eqnarray}
A \begin{pmatrix} x \\ y \end{pmatrix} &amp;=&amp;
x' A \begin{pmatrix} \alpha \\ 1 \end{pmatrix} +
y' A \begin{pmatrix} \beta  \\ 1 \end{pmatrix} \\
&amp;=&amp;
x' \alpha \begin{pmatrix} \alpha \\ 1 \end{pmatrix} +
y' \beta  \begin{pmatrix} \beta  \\ 1 \end{pmatrix} \\
&amp;=&amp;
\alpha x' \begin{pmatrix} \alpha \\ 1 \end{pmatrix} +
\beta  y' \begin{pmatrix} \beta  \\ 1 \end{pmatrix} \\
\end{eqnarray}
\]</p>
<p>これは (x, y) に左から A をかけるということは、
(x', y') 座標系では単に x' を \( \alpha \) 倍、y' を \( \beta \) 倍するだけ
であるということを示している。
(x', y') 座標系ではこの変換を行列表現すると</p>
<p>\[ \begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix} \]</p>
<p>である。
これを用いて (x, y) に左から行列 A をかけるのを以下のように表現する。</p>
<ol>
<li>与えられた (x, y) を一次変換し、(x', y') に座標変換する。</li>
<li>\( (x', y') \) を \( (x'', y'') = (\alpha x', \beta y') \) に変換する。
この変換は対角行列
\( \begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix} \)
で表される。
これは (x, y) 座標系では行列 A を左からかけているのに相当する。</li>
<li>移動後の (x'', y'') を逆変換し、(x', y') に直したものが求める答えとなる。</li>
</ol>
<p>固有ベクトルを基底とする座標系への変換行列を \( P^{-1} \) とすると、
これらの操作は以下のように表せる。</p>
<p>\[
\begin{eqnarray}
A \begin{pmatrix} x \\ y \end{pmatrix} &amp;=&amp;
P
\begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix}
P^{-1}
\begin{pmatrix} x \\ y \end{pmatrix}
\end{eqnarray}
\]</p>
<ol>
<li>(x, y) に左から P の逆行列をかけて固有ベクトルによる斜交座標に変換</li>
<li>固有ベクトルの性質より、固有値による単純なスケーリング変換を左からかける</li>
<li>左から P をかけて元の正規直交座標に戻す</li>
</ol>
<p>ここで、左から A を何度もかけることを考えると、行列とその逆行列との積は
単位行列になることに注意して、</p>
<p>\[
\begin{eqnarray}
A A \begin{pmatrix} x \\ y \end{pmatrix} &amp;=&amp;
P
\begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix}
P^{-1}
P
\begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix}
P^{-1}
\begin{pmatrix} x \\ y \end{pmatrix} \\
&amp;=&amp;
P
\begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix} ^2
P^{-1}
\begin{pmatrix} x \\ y \end{pmatrix} \\
A^n \begin{pmatrix} x \\ y \end{pmatrix}
&amp;=&amp;
P
\begin{pmatrix} \alpha &amp; 0 \\ 0 &amp; \beta \end{pmatrix} ^n
P^{-1}
\begin{pmatrix} x \\ y \end{pmatrix} \\
&amp;=&amp;
P
\begin{pmatrix} \alpha^n &amp; 0 \\ 0 &amp; \beta^n \end{pmatrix}
P^{-1}
\begin{pmatrix} x \\ y \end{pmatrix}
\end{eqnarray}
\]</p>
<p>教科書的に書くとこうだが、新しい座標系の中でスケーリングしたのち、
元の座標系に戻し、また新しい座標系に変換してスケーリングするのは無駄なので、</p>
<ol>
<li>新しい座標系に変換する</li>
<li>n 回スケーリングする</li>
<li>元の座標系に戻す</li>
</ol>
<p>の方が早いよね、というだけのことである。</p>
<p>これはもう解けており、具体的な値を代入すれば、</p>
<p>\[
\begin{eqnarray}
F_0 = 0 \\
F_1 = 1 \\
\end{eqnarray}
\]</p>
<p>\[
\begin{eqnarray}
\alpha &amp;=&amp; \dfrac{ 1 + \sqrt{5} }{2} \\
\beta  &amp;=&amp; \dfrac{ 1 - \sqrt{5} }{2}
\end{eqnarray}
\]</p>
<p>\[
\begin{eqnarray}
P &amp;=&amp; \begin{pmatrix} \alpha &amp; \beta \\ 1 &amp; 1 \end{pmatrix} \\
P^{-1}
&amp;=&amp;
\frac{1}{|P|} \begin{pmatrix} 1 &amp; -\beta \\ -1 &amp; \alpha \end{pmatrix} \\
&amp;=&amp;
\frac{1}{\alpha - \beta}
\begin{pmatrix} 1 &amp; -\beta \\ -1 &amp; \alpha \end{pmatrix}
\end{eqnarray}
\]</p>
<p>\[
\begin{eqnarray}
\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix}
&amp;=&amp;
A^n \begin{pmatrix} F_1 \\ F_0 \end{pmatrix} \\
&amp;=&amp;
P
\begin{pmatrix} \alpha^n &amp; 0 \\ 0 &amp; \beta^n \end{pmatrix}
P^{-1}
\begin{pmatrix} F_1 \\ F_0 \end{pmatrix} \\
&amp;=&amp;
\begin{pmatrix} \alpha &amp; \beta \\ 1 &amp; 1 \end{pmatrix}
\begin{pmatrix} \alpha^n &amp; 0 \\ 0 &amp; \beta^n \end{pmatrix}
\frac{1}{\alpha - \beta}
\begin{pmatrix} 1 &amp; -\beta \\ -1 &amp; \alpha \end{pmatrix}
\begin{pmatrix} 1 \\ 0 \end{pmatrix} \\
&amp;=&amp;
\frac{1}{\alpha - \beta}
\begin{pmatrix}
\alpha^{n+1} - \beta^{n+1} &amp;
- \alpha^{n+1} \beta + \alpha \beta^{n+1} \\
\alpha^n - \beta^n &amp;
- \alpha^n \beta + \alpha \beta^n
\end{pmatrix}
\begin{pmatrix} 1 \\ 0 \end{pmatrix} \\
&amp;=&amp;
\frac{1}{\alpha - \beta}
\begin{pmatrix}
\alpha^{n+1} - \beta^{n+1} \\
\alpha^n - \beta^n
\end{pmatrix} \\
F_n
&amp;=&amp;
\frac{1}{\alpha - \beta} (\alpha^n - \beta^n) \\
&amp;=&amp;
\frac{ 1 }{ \sqrt 5 } \left \{
\left ( \frac{ 1 + \sqrt{5} }{2} \right ) ^ n -
\left ( \frac{ 1 - \sqrt{5} }{2} \right ) ^ n
\right \}
\end{eqnarray}
\]</p>
<h3 id="余談"><a class="header" href="#余談">余談</a></h3>
<p>行列の n 乗の形に持っていけている時点で、それが対角化されていなくても
繰り返し二乗法を適用することで比較的少ない計算量で値を直接計算することができる。
一般解が求まれば n を代入するだけで計算量 \( O (1) \) で \( F_n \) が求まるが、
それができなくても、</p>
<p>\begin{eqnarray}
a^8 &amp;=&amp; a^4 \cdot a^4 \\
a^4 &amp;=&amp; a^2 \cdot a^2 \\
a^2 &amp;=&amp; a \cdot a \\
\end{eqnarray}</p>
<p>のように n 乗はより小さな n/2 乗を求めるという部分問題の解を使って
(漸化式や数学的帰納法の考え方) 高速に求めることができる(<strong>分割統治法</strong>)。
計算量は \( O(\log n) \) になる (底は 2)。
これは行列のべき乗にもそのまま適用できる。
このテクニックは行列累乗と呼ばれるが、競プロの中でだけかもしれない。
\( \log_2 n \) は指数関数の逆関数であり、まったく大きくならないので、
それなりの大きさの n に関しては実用上、ほぼ定数として扱える。</p>
<p>\begin{eqnarray}
2^8 &amp;=&amp; 256 \\
log_2 256 &amp;=&amp; 8 \\
2^{16} &amp;=&amp; 65536 \\<br />
log_2 65536 &amp;=&amp; 16 \\
2^{32} &amp;=&amp; 4294967296 \\
log_2 4294967296 &amp;=&amp; 32 \\
\end{eqnarray}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="フーリエ変換"><a class="header" href="#フーリエ変換">フーリエ変換</a></h1>
<ul>
<li>自然に思いつくことはほぼ不可能と思われるが、理工学では一般常識。
<ul>
<li>最近のトレンドでは裁判官の間でも一般常識らしい。本当かどうかは不明。</li>
</ul>
</li>
<li>一般常識かどうかは諸説あるが、一般常識として持っておくと生活が豊かになる。</li>
<li>正直数学がキツいところはあるというか、高校範囲外なのは事実である。</li>
<li>ただし概要やできることを知っているだけでも相当価値がある。</li>
</ul>
<p>できることの例</p>
<ul>
<li>音声データを周波数成分ごとに分解できる。それを元の音声信号に戻すこともできる。
<ul>
<li>ボーカルをカットしてカラオケ用のデータを自作する方法がこれ。</li>
</ul>
</li>
<li>可逆圧縮のほとんど効かない写真画像や音声データを効率的に圧縮できる。
<ul>
<li>jpeg や音声、動画圧縮の中身の基本はこれ</li>
</ul>
</li>
</ul>
<h2 id="波の基本"><a class="header" href="#波の基本">波の基本</a></h2>
<p>実際のところ、対象は音などの時間で変化する信号だけに限らない。
例えば、時間の代わりに画像ファイルの座標を使う、など (jpeg や動画の圧縮に使うよ)。
ただし用語の使い方も時間信号で考えた用語をそれ以外を対象にする場合も気にせずそのまま
使っている感じのため、とりあえず時間変化する信号と考えておき、
それ以外にも適用可能なことだけ気を付けておけばよい。</p>
<p>とりあえず sin (cos) 波を考える。
三角関数が最も基本的な波だから、とか、発電所ではタービンを円運動させているので
コンセントには sin 波が来ているから、とか適当なことを言って (きちんとした事実だが)
ごまかしながら導入するが、本当の理由は
「三角関数とは全然違う波だとしても、三角関数の重ね合わせとして分解できるから」
である。
例えば、太陽光 (電磁波) なんかは全く三角関数の形をしていない。
三角関数が最も基本的な波なのは事実で、使える数学のツールも非常に多い。
なので、三角関数でないものが三角関数だけの和で表せるのは超重要な事実である。</p>
<p>$$
\begin{aligned}
f(t) &amp;= A \sin (\omega t + \phi) \\
f(t) &amp;= A \sin (2 \pi f t + \phi) \\
f(t) &amp;= A \sin ( \frac { 2 \pi } { T } t + \phi) \\
f &amp;= 1 / T \\
\omega &amp;= \frac { 2 \pi } { T } = 2 \pi f \\
\end{aligned}
$$</p>
<ul>
<li>振幅 (amplitude)
<ul>
<li>三角関数の定数係数。波の振れ幅。</li>
<li>三角関数は -1 から 1 の範囲をふわふわするので、
\( -A \le f(t) \le A \)
の範囲で変化する波を表すことになる。
単位は波によって色々。音声信号なら音圧など。</li>
</ul>
</li>
<li>位相 (phase)
<ul>
<li>三角関数の中身。単位は角度 (rad など)。</li>
<li>360 度 ( \( 2 \pi \) rad) を一周期としたとき、その中のどのポイントにいるかを
角度で示したもの。</li>
</ul>
</li>
<li>波の変化速度 (相互変換可能)
<ul>
<li>角周波数 (angular frequency) \( \omega \)
<ul>
<li>三角関数内の時間に係数をつける形で $ \omega t $ のようにしたもの。</li>
<li>単位は (角度 / 時間) で、rad / s 等。
時間に掛け算すると角度となり三角関数に入れられる。</li>
<li>単位時間あたり、一周期を 360 度とした割合で何度分進むか。</li>
<li>合成関数の微分積分でそのまま外に出てくるため、数式処理する場合に一番読みやすい。</li>
</ul>
</li>
<li>周期 \( T \)
<ul>
<li>繰り返しの一回分に何秒かかるか。分かりやすい。</li>
<li>単位は時間。s。</li>
</ul>
</li>
<li>周波数 \( f \)
<ul>
<li>1秒に何回繰り返されるか。こちらも分かりやすい。周期とお互いに逆数の関係にある。</li>
<li>単位は 1/s。Hz (ヘルツ) の方をよく使う。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="フーリエ級数展開"><a class="header" href="#フーリエ級数展開">フーリエ級数展開</a></h2>
<ul>
<li>三角関数とは似ても似つかないが、周期 T で繰り返してはいる信号があるとする。</li>
<li>そんな都合よく周期 T でずっと繰り返す信号ばかりじゃない (例: 音声ファイル)、
と思うかもしれないが、その場合は音声ファイルの長さを T とし、
左右に無限回コピペし続ければ周期 T の信号と言えなくもない。</li>
<li>これが苦しい言い訳に聞こえて仕方ない場合は、フーリエ変換まで我慢する。</li>
</ul>
<p>驚くべき事実として、周波数
\( f = 1/T \)
の任意 (本当に任意とは言っていない) の信号は、周波数
\( f, 2f, 3f, 4f, 5f, \ldots \)
の三角関数の無限個の和に分解できる (ことが多い)。
もともとかなり無茶なことをしようとしているので、数学的に厳密な議論をしようとすると
とんでもないことになる (Wikipedia 参照) ため、数学徒以外は無理をしてはいけない。</p>
<p>式で書くときは角周波数で書いた方が目に優しいため、基本角周波数を
\( \omega _0 = \frac { 2 \pi } { T } \)
とし、その整数倍の角周波数の三角関数を考える。
周波数のみを固定したとき、振幅と初期位相の2つが自由に決められるパラメータとなるから</p>
<p>$$
\begin{aligned}
C_1 &amp; \sin ( 1 \omega _0 t + D_1 ) \\
C_2 &amp; \sin ( 2 \omega _0 t + D_2 ) \\
C_3 &amp; \sin ( 3 \omega _0 t + D_3 ) \\
\ldots \\
C_k &amp; \sin ( k \omega _0 t + D_k )\\
\ldots
\end{aligned}
$$</p>
<p>のような波を重ね合わせることになる。
1つを選んで加法定理を使って変形すると、</p>
<p>$$
\begin{aligned}
&amp; C_k \sin ( k \omega _0 t + D_k ) \\
&amp;= C_k ( \sin k \omega _0 t \cos D_k + \cos k \omega _0 t \sin D_k) \\
&amp;= (C_k \cos D_k) \sin k \omega _0 t + (C_k \sin D_k) \cos k \omega _0 t \\
&amp;= A_k \sin k \omega _0 t + B_k \cos k \omega _0 t
\end{aligned}
$$</p>
<p>のようになる。</p>
<p>任意の A, B (sin の振幅と cos の振幅) を決めるのは
任意の C, D (1つの三角関数の振幅と位相) を決めるのと同じ、
という順番で説明されることが多いが、それは三角関数の合成を根拠にされる。
三角関数の合成は加法定理の逆をやっているだけなので、
とにかく2つの表現はどちらも同じことである。</p>
<p>ここでちょっと準備をする。
なぜか高校数学ではあまり注目されない気がするが、以下の事実がある。</p>
<p>$$
\begin{aligned}
n, m = 1, 2, 3, \ldots \\
\int_0^{2 \pi} \sin n t \sin m t dt &amp;= 0 \quad (n \ne m) \\
\int_0^{2 \pi} \cos n t \cos m t dt &amp;= 0 \quad (n \ne m) \\
\int_0^{2 \pi} \sin n t \cos m t dt &amp;= 0 \quad \\
\end{aligned}
$$</p>
<p>整数倍の周波数の sin や cos について、周波数の異なるもの同士を掛けたもの、
または周波数が同じだとしても sin と cos を掛けたものは
基本周期で積分すると 0 になる。
見た目がゴツいので例を書き下すと</p>
<p>$$
\begin{aligned}
\int_0^{2 \pi} \sin t \sin 3 t dt &amp;= 0 \\
\int_0^{2 \pi} \cos 5 t \cos 8 t dt &amp;= 0 \\
\int_0^{2 \pi} \sin 2 t \cos 2 t dt &amp;= 0 \quad \\
\end{aligned}
$$</p>
<p>のような感じである。</p>
<p>証明はただ積分を計算するだけだが、積を積分するのは難しいので和の形に変形する
(三角関数は使える道具が多い)。
一言で言うと積和の公式なのだが、要は加法定理をいじって積を和に変換する式を
作るだけである。</p>
<p>sin の加法定理をよく見ると三角関数の積が右辺にある。
プラスマイナスの2つの式を上下に並べて辺々足し算 (または引き算) すれば
sin と cos の積を和に直せる。</p>
<p>$$
\begin{aligned}
\sin (\alpha + \beta) &amp;= \sin \alpha \cos \beta + \cos \alpha \sin \beta \\
\sin (\alpha - \beta) &amp;= \sin \alpha \cos \beta - \cos \alpha \sin \beta \\
\sin (\alpha + \beta) + \sin (\alpha - \beta) &amp;= 2 \sin \alpha \cos \beta
\end{aligned}
$$</p>
<p>右辺が今積分できずに困っている形、左辺は楽に積分できる形になっている。</p>
<p>cos の加法定理を辺々いい感じにすれば sin 同士または cos 同士の積を和に直せる。</p>
<p>$$
\begin{aligned}
\cos (\alpha - \beta) &amp;= \cos \alpha \cos \beta + \sin \alpha \sin \beta \\
\cos (\alpha + \beta) &amp;= \cos \alpha \cos \beta - \sin \alpha \sin \beta \\
2 \sin \alpha \sin \beta &amp;= \cos (\alpha - \beta) - \cos (\alpha + \beta) \\
2 \cos \alpha \cos \beta &amp;= \cos (\alpha - \beta) + \cos (\alpha + \beta) \\
\end{aligned}
$$</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
