<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>マルチコアと同期 - 3日ではなれないかもしれない人形遣い</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">3日ではなれないかもしれない人形遣い</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="マルチコアと同期"><a class="header" href="#マルチコアと同期">マルチコアと同期</a></h1>
<p>3行まとめ</p>
<ul>
<li>ロックを使え。</li>
</ul>
<h2 id="マルチスレッド"><a class="header" href="#マルチスレッド">マルチスレッド</a></h2>
<p>シングルコアでは物理的に同時に動くのは1つのプログラムである。
しかし、その時代から OS によるマルチタスキング・マルチスレッドの概念はあった。
OS が適当なタイミング (特別な理由がなければタイマ割り込み) を契機に実行中の
スレッドから実行権を剥奪 (プリエンプト) し、別のスレッドに切り替える。</p>
<p>※それより前は OS ではなくアプリケーションが自ら CPU を手放す協調的スケジューリングも
あったが、アプリがバグると CPU を放さなくなってしまうので、現代の OS ではシステムが
勝手に (タイマ割り込みで) タスクを切り替える、
プリエンプティブスケジューリングが採用されることが多い。
ただし OS のスレッドの上でユーザランドでタスクを切り替えるグリーンスレッドだとか
最近流行りの async-await <sup class="footnote-reference"><a href="#1">1</a></sup>: 系の話では協調的スケジューリングも現役と言える。</p>
<p>現代ではシングルコア性能の向上に限界を迎え、CPU のマルチコア化が進んでいる。
ハードウェア設計の方の話で N コア M スレッドのように言われると
コアという用語が何を指すのか分かりづらいため、ソフトウェア/OS の世界では
「CPU0, CPU1, ...」「ハードウェアスレッド」のような呼び方をすることも多い。
物理コア、論理コアという便利な言い回しもある。
しかし口語では簡単にコアと言ってしまうことも多く、要はプログラムを物理的に
同時に実行できる単位1つ分のことである。</p>
<p>マルチコア用 OS では、スレッドを同時にコア数分まで同時に物理的に実行することができる。
しかしそれより多くは不可能なので、そこから先はシングルスレッドと同様の方法で
スレッドの切り替えを行うことになる。</p>
<p>マルチコア環境では複数のプログラムを同時に実行するとマルチコアの恩恵を受けやすいが、
1つのプログラムに関してはマルチスレッドプログラミングを意識して行わないと
マルチコアの恩恵をほとんど受けられない。</p>
<p>PC の CPU 使用率の (できればコアごとの) モニタを見てみると分かるが、
現代の PC においては、一部の限られた作業以外では CPU コアを持て余しているのが
普通である。
シングルコアの時代では割と頻繁に CPU 使用率が 100% に「張り付いていた」が、
現代では全コア 100% となることは一部のタスクを除いてほとんどない。
したがって CPU が実行速度のボトルネックになることは少なく、
高級なコア数の多い CPU を選ぶ価値は低い。</p>
<p>ただしマルチコア CPU の並列性を大いに生かした作業を行う場合は例外であり、
低性能なコア数の少ない CPU を強制的に使用させるような行為は基本的人権の侵害となる。</p>
<ul>
<li>プログラムの並列ビルド</li>
<li>将棋の手読み</li>
<li>AI のための行列演算は GPU を用いた方がよい。</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>共通しているのは見た目や使い勝手のみで、
具体的に何が起こるかはプログラミング言語ごとにバラバラで一概には言い難い。</p>
</div>
<h2 id="主流のハードウェア構成"><a class="header" href="#主流のハードウェア構成">主流のハードウェア構成</a></h2>
<p>主流でなければ色々な構成が考えられるという前提の上で、PC やスマホ等で主流の構成は</p>
<ul>
<li>N コア M スレッド
<ul>
<li>例: 8 コア 16 スレッド</li>
<li>プログラムの実行主体が 1 コアあたり (M/N) 本ある、という意味。</li>
<li>ソフトウェア視点、OS を書くくらいの視点以上からは単に M コアであるとみなして
問題ない。</li>
<li>例: 8 コア 16 スレッド =&gt; OS からは CPU0..15 の 16 コアあるように見えるはず</li>
</ul>
</li>
<li>L1 キャッシュ (コアごと) SRAM</li>
<li>L2 キャッシュ (共通)</li>
<li>L3 キャッシュ (共通)</li>
<li>メモリ DRAM
<ul>
<li>CPU の速度向上に置いて行かれてとんでもなく遅い(だからキャッシュがある)。</li>
</ul>
</li>
</ul>
<h3 id="simultaneous-multi-threading-smt"><a class="header" href="#simultaneous-multi-threading-smt">Simultaneous Multi-Threading (SMT)</a></h3>
<p>N コア M スレッドの補足。
SMT と呼ばれる技術である。
Intel 用語だと Intel Hyper-Threading。</p>
<p>(CPU 設計上の狭い意味で) コアと呼ばれるものの1つ1つの中には、
演算器やメモリの読み書きユニット、L1 キャッシュのような各種ユニットが含まれている。</p>
<p>コアごとに各クロックで、1命令を細かく切り刻んだステージを複数命令分同時に実行していく
(パイプライン実行) のだが、その様子を観察するとハードウェアユニットを各クロックで
100% 使用していないということが分かった
(普通のプログラムを普通に動かして各ユニットが各クロックで 100% フル稼働するとは
考えにくい)。</p>
<p>そこで、あるユニットを使いたいときは隣のスレッドが使い終わるまで待つような調停を
入れつつ、物理コア内で2本のハードウェアスレッドを実行できるようにしたものである。
加算器やメモリロードストアユニットのようなよく使われるものはそれなりに競合するだろうし、
1コアあたり2スレッドとしたところで性能は2倍とはならない。
実際のところ、1.3 倍程度？らしい。</p>
<h2 id="スレッドライブラリ"><a class="header" href="#スレッドライブラリ">スレッドライブラリ</a></h2>
<p>だいたいのところ、関数をスレッド生成関数に渡すとそれを別スレッドとして
実行開始してくれることが多い。
スレッドの起動パラメータを渡せることもあれば、クロージャの環境キャプチャを使えと
言われることも。move セマンティクスに対応していると嬉しい。
ラムダ式があると記述が楽なこともあれば、大きなスレッドは普通に関数として書きたいことも。</p>
<p>join でスレッド終了の待ち合わせと返り値を受け渡せることが多い。
ただし実戦は別スレッドでのエラー (or 例外) 処理とリソースの解放義務が複雑に絡み合い
カオスになりがち。Rust を使おう。</p>
<h3 id="pthread"><a class="header" href="#pthread">pthread</a></h3>
<p>POSIX 標準の C API。</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

void *print_hello(void *arg) {
    printf("Hello, World!\n");
    return NULL;
}

int main() {
    pthread_t thread1;

    if (pthread_create(&amp;thread1, NULL, print_hello, NULL) != 0) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    if (pthread_join(thread1, NULL) != 0) {
        fprintf(stderr, "Error joining thread\n");
        return 1;
    }

    return 0;
}
</code></pre>
<h3 id="stdthread"><a class="header" href="#stdthread">std::thread</a></h3>
<p>余計な記述が少なく結構使いやすい。
スレッド内で発生した例外が join() で受け取れたり、結構頑張っている。</p>
<pre><code class="language-C++">#include &lt;cassert&gt;
#include &lt;thread&gt;

int main()
{
  int x = 0, y = 0;

  std::thread t([&amp;]{ ++x; });
  --y;
  t.join();

  assert(x == 1 &amp;&amp; y == -1);
  return 0;
}
</code></pre>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>スレッドセーフでないコードはコンパイルが通らない。</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<h2 id="競合状態-race-condition"><a class="header" href="#競合状態-race-condition">競合状態 (race condition)</a></h2>
<p>スレッド間で通信をするためには、メモリ空間を共有していることを考えると、
共有メモリを読み書きするのが手軽である。</p>
<p>以下は shared_mem を 256 スレッドから 1000000 回インクリメントするが、
256000000 にはならない (ことがある)。</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

void *proc(void *arg) {
  int *shared_mem = (int *)arg;
  for (int i = 0; i &lt; 1000000; i++) {
    (*shared_mem)++;
  }

  return NULL;
}

int main() {
  pthread_t th[256];
  int shared_mem = 0;

  for (int i = 0; i &lt; 256; i++) {
    if (pthread_create(&amp;th[i], NULL, proc, &amp;shared_mem) != 0) {
      fprintf(stderr, "Error creating thread\n");
      return 1;
    }
  }
  for (int i = 0; i &lt; 256; i++) {
    if (pthread_join(th[i], NULL) != 0) {
      fprintf(stderr, "Error joining thread\n");
      return 1;
    }
  }

  printf("shared_mem = %d\n", shared_mem);

  return 0;
}
</code></pre>
<p>このように何の工夫もなく複数のスレッドから共通のメモリを読み書きすると、色々と壊れる。
しかも確率的にごく稀に壊れることもある。
これを競合状態 (race condition)、スレッドセーフでない等という。</p>
<p>スレッドセーフでないコードが具体的にどうなるかは非常に説明が難しい。
当然ハードウェア実装にもよる。</p>
<p>昔ながらの教科書では以下のように説明されることが多いし、一旦はこれで納得すること。
でも～なケースなら大丈夫じゃないの？と思ったりするかもしれないが、
大抵の場合全然大丈夫じゃないので CPU 内部の挙動を説明できるレベルにない間は
必ずロックを取ること。</p>
<ol>
<li>スレッドAがメモリから値 0 を CPU 内に読む</li>
<li>スレッドBがメモリから値 0 を CPU 内に読む</li>
<li>スレッドAが CPU 内でインクリメントを行い、値 1 を CPU 内に用意する</li>
<li>スレッドAがメモリへ値 1 を書き込む</li>
<li>スレッドBが CPU 内でインクリメントを行い、値 1 を CPU 内に用意する</li>
<li>スレッドBがメモリへ値 1 を書き込む</li>
</ol>
<ul>
<li>まず、コンパイラの最適化がかかる。コンパイラ最適化はシングルスレッドでの実行結果が
変わらないことしか保証しない。
<ul>
<li><code>volatile int *</code> とすると、1000000 回メモリに書き込む機械語が生成されることは
保証される。ただし volatile 単独ではスレッドセーフにはならない。
巷にはインチキコードが溢れているので注意。</li>
</ul>
</li>
<li>高機能なプロセッサでは Out-of-Order 実行によって CPU の内部で機械語の実行順序を
並べ替えられる。こちらもシングルスレッドでの実行結果が変わらないことしか保証しない。
<ul>
<li>こんなとんでもないことをわざわざする理由については、CPU 設計のパイプラインと
命令間依存性、ハザードの話を参照。</li>
</ul>
</li>
<li>パイプライン実行によって1命令を数～数十ステージに分割し、何クロックもかけて、
他の命令と同時並列で実行する。</li>
<li>そのような CPU コアが複数あり、それぞれが同一クロックで独立して動いている。</li>
</ul>
<p>Note: 読み出しのみならセーフ。
メモリに置いた定数を複数スレッドから共有するのは問題ない。</p>
<p>そのままだとレースコンディションを起こしてしまうようなコード区間を
クリティカルセクションという。
クリティカルセクションを保護してスレッドセーフにするために待ち合わせ等を
行うことを同期をとる (synchronize) という。</p>
<h2 id="ロック-ミューテックス-mutex"><a class="header" href="#ロック-ミューテックス-mutex">ロック (ミューテックス, Mutex)</a></h2>
<p>ロックは同時に一人しか獲得する (acquire) ことができない同期プリミティブである。
とりあえずこれを覚えるだけで OK と言っても過言ではない。
クリティカルセクションが終了したら解放する (release)。</p>
<p>ロックが取れない場合、スレッドを sleep 状態
(カーネルのスケジューラによる管理状態の1つ) に入れてアンロックされるまで
スケジュールから外される。
ただしこれはコンテキストスイッチが伴いオーバーヘッドが大きいので、
ロックを持っているスレッドが他のコアにおり、相手がメモリを少しいじって
即アンロックするだけならばそのままビジーループで待った方が効率よい(マルチコアの場合)。
よって一定回数スピン (ビジーループ) して待ち、それでも取れないなら
スリープするという最適化がよく行われる。</p>
<h3 id="ユーザランドスピンロック-上級者向け"><a class="header" href="#ユーザランドスピンロック-上級者向け">ユーザランドスピンロック (上級者向け)</a></h3>
<p>スレッドをスリープに入れるとか、相手がアンロックした時に起きてくるとかは
カーネルランドでしかできないので、mutex lock/unlock には
システムコールを発行する必要がある。</p>
<p>それが嫌な場合、スリープを諦めることを条件に、
スピンロックをユーザランドで実装することは不可能ではない
(スピンロックを作るためのアトミック命令はユーザモードでも実行可能なため)。
ただし、ユーザモードのコードは常にタイマ割り込みによってカーネルにプリエンプトされる
可能性があり、それを防ぐ術もない。
ロックを持ったスレッドが CPU を奪われると、再度 CPU を割り当てられて
アンロックを実行するまで待っているスレッドはビジーループでそのコアを使用率 100% で
使い潰すことになる。
とはいえ、現代の PC/サーバ クラスのマルチコア環境で全コアを使い切っている状況は
ほとんどなく、持て余しているというのも実情である。
なので実行可能 (CPU 割り当て可能) 状態のスレッド数がコア数を上回り続けることは
ほとんどなく、ロックを持ったスレッドが CPU を奪われたままになり続けることは
ほとんどないと言えなくもない。</p>
<p>というわけで私からは評価不能である。
とりあえず、とあるデータベースソフトウェアがそのようなことをやっていて、
Linus からは pure garbage などという暴言を頂いたようだ。</p>
<h3 id="rwlock"><a class="header" href="#rwlock">RwLock</a></h3>
<p>読み出しはよく行われるが、書き換えは稀にしか起こらないようなケースがある。
複数の読み出しはロックなしで同時に行っても安全だが、
書き換え中は他のスレッドの読み出しと書き込み両方を禁止する必要がある。</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Read</th><th>Write</th></tr></thead><tbody>
<tr><td>Read</td><td>OK</td><td>NG</td></tr>
<tr><td>Write</td><td>NG</td><td>NG</td></tr>
</tbody></table>
</div>
<p>いずれか1つが Write アクセスの場合は Mutex と同じだが、
すべて Read アクセスの場合はロックなしの動作になるようなロックがあると効率がよい。
それが Read Write Lock または Exclusive Shared Lock と呼ばれるものである。
ファイルロックも同じような仕組みが提供されることが多い。</p>
<h2 id="条件変数-condition-variable"><a class="header" href="#条件変数-condition-variable">条件変数 (Condition Variable)</a></h2>
<p>ユーザランドで Mutex を使えば、ロックを取れなかったときにスレッドをスリープ状態にして
OS に CPU (コア) を他のスレッドに割り当ててもらって CPU を有効活用できる。
また、スリープ状態のスレッドは実行可能になったら適切に起こす (wake up) 必要がある。</p>
<p>このスリープをもっと汎用的に使えるように設計されたのが、条件変数である。
モニタパターンとも呼ばれる。
ちょっと使い方にクセがあって条件変数という名前も直感的でないが、
非常に汎用性が高く、一度覚えれば CPU を適切に割り当てるプログラムが書けるようになる。
条件変数という名前の由来は私もよく分からないので少なくとも名前の意味を
考えるのはやめておくのをおすすめする。</p>
<p>条件変数は単独で使用するのではなく、他の要素と同時にパターンに従って
使用されることを前提として設計されている。</p>
<ul>
<li>Mutex またはそれに類するロック</li>
<li>その Mutex で保護された変数群</li>
<li>その Mutex に関連付けられた条件変数とモニタ条件</li>
</ul>
<p>使い方は決まっているのでまずは使い方を丸覚えしたほうがよい。</p>
<pre><code class="language-C">// mutex = init_mutex();
// condvar = init_condvar(mutex);
mutex.lock();
while (!(condition)) {
  // unlock and sleep
  condvar.wait();
  // wakeup and lock
}
do_something1();
mutex.unlock();
</code></pre>
<ol>
<li>まず、とにもかくにもロックを取得し、クリティカルセクションに入る。</li>
<li>この時点で共有変数には自分一人しかアクセスできないことが保証されている。
ロックで保護された変数を読み取り、「条件」が満たされていないならば
その条件に対応させる「条件変数上で待機する (wait)」。
ここで、if 文ではなく while 文としておく。
理由は後述するが、最初は定型文として覚えてしまった方がよい。</li>
<li>wait は <strong>ロックを外し</strong>、このスレッドをスリープさせる。
対象の条件変数のモニタに入る、とも言う。</li>
<li>wait は 対象の条件変数に対して通知 (notify, signal, wakeup などと言われる)
が来ると起きる。これについては後述。
また、<strong>ロックを再度取得した状態で</strong> 起きてくる(そういう風に頑張って作られている)。</li>
<li>起床後、もう一度同じ条件を確認する。ロックを持った状態で起きてくるので安全である。
条件が満たされているのを確認できた場合はループを抜けて本処理に入る。
条件が満たされていない場合は前回と同様にもう一度 wait する。</li>
<li>満たされた条件のもと何らかの処理を行い、アンロックし、完了。</li>
</ol>
<p>while ループとしておき起床後に再度同じ条件をチェックする理由は</p>
<ul>
<li>spurious wakeup といって、起こされていないのに起きる可能性がある。
<ul>
<li>ほとんどのユーザランドライブラリで注意されている。</li>
</ul>
</li>
<li>他にも同じ条件変数で寝ているスレッドがあり、ロックを取りながら起きようとする際に
他のスレッドに負け、勝ったスレッドがロック状態のうちに条件を満たさないように
保護された変数を変更した場合、ロックを取れた頃には条件が満たされない状態に
なってしまっている。</li>
</ul>
<p>前者はユーザランドでどんな状況でも厳密に正しく実装するのが重すぎるから、らしいが
具体的なところはよくわからない。
シグナルによる EINTR のハンドリングが絡むとよくないとの噂がある。
Linux や FreeBSD のカーネル用関数では spurious wakeup は触れられておらず、
起きないのかもしれない。
しかし後者の問題は常に対応する必要があり、後者を対応すれば自然に前者にも
対応できるのだから、結論は簡単で常に while のロジックを使うべきである。</p>
<p>プログラミング言語やライブラリによっては <code>while (!(condition))</code> の condition の
部分をラムダ式等で渡せる (渡すしかない) ようになっているものもある。</p>
<ul>
<li>while を使わない等の間違った使い方を封殺する。</li>
<li>while の中に成立を待つ条件の否定を書かないといけないのを、
関数から肯定の条件を返すようにできる。</li>
</ul>
<pre><code class="language-C">// mutex = init_mutex();
// condvar = init_condvar(mutex);
mutex.lock();
do_something2();
if (condition) {
  condvar.notify_all();
}
mutex.unlock();
</code></pre>
<ol>
<li>起こす側も、まずロックは取得する。
起こす側と起こされる側を同一ロジックにすることも可能だが、使い方を理解すれば
自然にそのようにも書けるようになる。</li>
<li>ロックで保護された変数を操作し、もし条件が満たされるようになり
条件が満たされず寝ているスレッドがいるなら起こす必要がある場合、
notify 操作を行う。
notify_one, notify_all (wakeup_one, wakeup_all) のように複数の機能が提供
されている場合があるが、よほど自信がある場合以外は notify_all を強くおすすめする。</li>
<li>アンロックして完了。</li>
</ol>
<h2 id="注意-volatile-は罠"><a class="header" href="#注意-volatile-は罠">注意: volatile は罠</a></h2>
<p>CON02-C. volatile を同期用プリミティブとして使用しない</p>
<p><a href="https://www.jpcert.or.jp/sc-rules/c-con02-c.html">https://www.jpcert.or.jp/sc-rules/c-con02-c.html</a></p>
<p>volatile は主にメモリマップされたハードウェアレジスタを読み書きすることを
意図したもので、単体でスレッドセーフにする効果はない。
メモリアクセスをコンパイラ最適化で省略しないというのは共有メモリで通信する以上
必須ではあるのだが、それだけでは全然足りないためである。
生成される機械語が変わるので、レースバグの再現率を変える実験くらいにしか使えない。
レースバグは絶対に直らない。</p>
<ul>
<li>volatile オブジェクトへの読み書きのメモリアクセスは省略されない。
<ul>
<li>Memory Mapped I/O (メモリアクセス命令で特定レンジへのアクセスが
メインメモリではなく他のハードウェアデバイスへ飛んで制御できる方法。)
がうまくいくようになる。</li>
<li>2回異なるデータを同じ場所に書き込んだ時、1回目は無駄だからといって
省略してはならない。それは通常のメモリの場合であって、それ以外の
ハードウェアデバイスへの書き込みには意味がある可能性がある。
1を書き込んだタイミングで処理開始、とか。</li>
<li>複数回の同一アドレスからの読み出しも省略してはならない。
CPU 外のハードウェアは CPU とは独立して動作しており、
読み出される値は変更される可能性がある
(volatile = 揮発性 = 何もしなくても状態が勝手に変わる)。</li>
</ul>
</li>
<li>メモリを使わずレジスタだけで済ませるという最適化も無効。</li>
</ul>
<p>難しい話が分からない場合は、書き込みを伴う共有変数には必ずロックを使うこと。
ロックに代表される同期プリミティブと呼ばれるオブジェクトは、
難しい話を全てクリアしてある。</p>
<h2 id="アトミック命令-ここから上級者向け"><a class="header" href="#アトミック命令-ここから上級者向け">アトミック命令 (ここから上級者向け)</a></h2>
<p>古い OS の教科書にはピーターソンのアルゴリズムやデッカーのアルゴリズムなど、
ハードウェアサポートなしで同期を取ろうとする天才プログラムが載っていたりするが、
Out-of-Order + マルチコアのような現代の世紀末環境では全く通用しないし、
専用の命令をハードウェアに用意してもらった方が効率的で使い方も簡単である。</p>
<p>アトミック性 (atomicity) とは、不可分性と訳され、他の実行コンテキストから
その命令の実行前と実行後のどちらかの状態しか観測されないという性質のことである。
逆に言うとアトミックと明示的に言われない限りは保証されないと思っておいた方がよい。</p>
<p>アトミック性の概念自体は CPU の提供するアトミック命令だけではなく、
もっと広く用いられるものである。
例えばロックを取っている間に複数の変数を変更した場合、同じくロックを取ってアクセスする
他のスレッドからは、ロックを取る前かロックを解除した後の状態しか観測されない。</p>
<p>実際のところ、メモリアラインされた 32 bit ロード or ストアは
何もしなくてもアトミックになることが多い。
明示的にアトミック命令と言われた場合、read-modify-write (atomic-add, atomic-swap)
を指すことが多い。
メモリを読んで、それに何か計算をして、結果を書き込む、という操作は
典型的なレースコンディションを引き起こす操作だが、
現代の CPU ではそれくらいなら専用命令を呼ぶだけでアトミックに
処理できるということである。
アトミック命令は内部的にはバスロック (ハードウェア論理レベルでメモリバスを占有する) で
実装されることが多い、気がする。多分。</p>
<p>(アトミック命令で実装されている) ロックを使わずアトミック命令を直接呼ぶだけで
実現可能な単純なロジックならば、アトミック命令で実装した方が性能は上がる可能性が高い。
外部からのキャンセルリクエストのようなものならば atomic bool 等で十分かもしれない。
ただしスレッドセーフにしなければならないデータ構造が変数2つ以上になった瞬間
ロックで書き直さなければならなくなったりもする。
可読性やメンテナンス性とのトレードオフとなるのでよく考えること。</p>
<h2 id="メモリオーダリングメモリバリアフェンス"><a class="header" href="#メモリオーダリングメモリバリアフェンス">メモリオーダリング・メモリバリア・フェンス</a></h2>
<p>アトミック性自体はアトミック命令を呼べば実現するが、
アトミック性だけで十分なケースは大して多くない。</p>
<p>あるスレッドがメモリを書き換えたとき、その書き換えの順番が他のスレッドから
同じ順番で見えるとは保証されないことがあるからである。
コンパイラ最適化による命令の並べ替えもその一種と言えなくもないが、
こちらは volatile で制御できなくもない。
問題は CPU のアウトオブオーダ実行による CPU 内部での命令の並べ替えである。</p>
<p>現代の性能重視の CPU は、シングルスレッドで考えた実行結果が変わらないという制約の下で、
命令の実行順を入れ替えることがある。
これは現代 CPU の中でも最も複雑な部分と思われる。
アウトオブオーダ機能の自作はおすすめしないしデバッグも困難を極める。
なぜわざわざそんなことをするかというと、そうした方が速いケースがあるからである。
命令の (パイプライン化され細かく分かれたステージのうちの) 実行には入力オペランド
(例えば、足し算なら、その対象の2つのレジスタなど) が確定している必要があるが、
そのレジスタが直前の命令によって書き込まれる</p>
<h2 id="メモリモデル一貫性モデル"><a class="header" href="#メモリモデル一貫性モデル">メモリモデル・一貫性モデル</a></h2>
<h2 id="ロックの作り方"><a class="header" href="#ロックの作り方">ロックの作り方</a></h2>
<h3 id="割り込み禁止-シングルコア専用カーネルモード専用"><a class="header" href="#割り込み禁止-シングルコア専用カーネルモード専用">割り込み禁止 (シングルコア専用・カーネルモード専用)</a></h3>
<p>シングルコア限定で絶対にレースしない必殺技があって、それが割り込み禁止である。</p>
<p>CPU の割り込み機能はオフにできるため、そうしている間は突然実行コンテキストが切り替わる
ことが絶対にない (NMI (Non-Maskable Interrupt) は除く)。
タイマ割り込みも無効になる。</p>
<p>ただし当然、早急な処理を求められる外部ハードウェアへの応答が遅れるため、
長時間のロックはご法度である。
またこれも当然、カーネルモード (OS の中) でしか変更できない。</p>
<p>割り込みハンドラとの間でも同期が取れることになるが、
割り込みハンドラと変数を共有していない場合はプリエンプト禁止で十分かもしれない。
プリエンプト禁止は CPU のハードウェア設定ではなく、OS 上でのソフトウェア的な
制御になる。</p>
<h3 id="スピンロック-マルチコア向けカーネルモード向け"><a class="header" href="#スピンロック-マルチコア向けカーネルモード向け">スピンロック (マルチコア向け・カーネルモード向け)</a></h3>
<p>アトミック命令を使って初めに作ることになる、最も単純なロックである。
シングルコアではビジーウェイト (メモリの値が変わるまで読み続ける) は
他のスレッドにスイッチしてメモリが書き換えられるまで無駄に CPU 時間を消費するため
行儀の悪いスタイルと言われるが、マルチコアではビジーウェイト中も他のコアが動けるため、
ロック時間が十分短いならばコンテキストスイッチのコストがかからずむしろ
性能のよいロックとなる。
また、割り込みハンドラ同士または割り込みハンドラとスレッドコンテキストとの間の
ロックとしても使用可能である。</p>
<p>データ構造としては、ロック本体はメモリ上に 1 word 程度の整数を用意するだけで
ロック1つを実現できる。</p>
<p>xv6 (RISC-V) での実装</p>
<pre><code class="language-C">// Mutual exclusion lock.
struct spinlock {
  uint locked;       // Is the lock held?

  // For debugging:
  char *name;        // Name of lock.
  struct cpu *cpu;   // The cpu holding the lock.
};
</code></pre>
<p>スピンロックを取得した状態で解放前に自身のコアで割り込みが入り、
その割り込みハンドラで同じロックを取得しようとした場合、デッドロックして
コアが割り込みハンドラ内で固まってしまう。
そのため初めにローカルコア割り込みを OFF にしている。
割り込みハンドラからロックしないならば、これは不要とも言える。
ただしタイマ割り込みからのプリエンプトは禁止すべきだろう。
オープンソースの OS の実装を見て回るのもよい。</p>
<p>次の <code>__sync_lock_test_and_set()</code> がアトミック命令で、ロックの本体である。
アセンブラで直接書くか、このように gcc 拡張を使って多少ハードウェア非依存っぽく
書くこともできる。
このようなコンパイラ拡張は、コンパイラへの命令並べ替え禁止効果を含んでいて便利である。
自力でやるときは <code>asm volatile</code> と <code>memory</code> 指定を使う。</p>
<p><code>test_and_set</code> は名前と違って atomic_swap に近いらしい。
「メモリを読んで返す」のと「メモリに第二引数 (1) を書き込む」を同時に行い、
その途中状態を他のコアから観測されないようにする。
具体的にはメモリバスロックを行い、自分以外のコアのメモリアクセスを禁止するとか。多分。</p>
<p>コードとしてはメモリ内容と 1 をアトミックに交換し、0 が取得された場合は
ロックが取れた (ロック変数を0から1に変更した) とみなし、
1 が取得された場合はロックが取れなかった (ロック変数は1から1のまま) とみなす、
というだけのことである。
ロックのキモはたったこれだけではある。
両方のスレッドからアクセス可能な 1 word 程度のメモリがあれば実現できる。
ただし、現代の CPU では考慮すべき事項が多い。</p>
<pre><code class="language-C">// Acquire the lock.
// Loops (spins) until the lock is acquired.
void
acquire(struct spinlock *lk)
{
  push_off(); // disable interrupts to avoid deadlock.
  if(holding(lk))
    panic("acquire");

  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
  //   a5 = 1
  //   s1 = &amp;lk-&gt;locked
  //   amoswap.w.aq a5, a5, (s1)
  while(__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)
    ;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that the critical section's memory
  // references happen strictly after the lock is acquired.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Record info about lock acquisition for holding() and debugging.
  lk-&gt;cpu = mycpu();
}

// Release the lock.
void
release(struct spinlock *lk)
{
  if(!holding(lk))
    panic("release");

  lk-&gt;cpu = 0;

  // Tell the C compiler and the CPU to not move loads or stores
  // past this point, to ensure that all the stores in the critical
  // section are visible to other CPUs before the lock is released,
  // and that loads in the critical section occur strictly before
  // the lock is released.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Release the lock, equivalent to lk-&gt;locked = 0.
  // This code doesn't use a C assignment, since the C standard
  // implies that an assignment might be implemented with
  // multiple store instructions.
  // On RISC-V, sync_lock_release turns into an atomic swap:
  //   s1 = &amp;lk-&gt;locked
  //   amoswap.w zero, zero, (s1)
  __sync_lock_release(&amp;lk-&gt;locked);

  pop_off();
}
</code></pre>
<p>ロックを使わずアトミック命令でスレッドセーフに書く (ロック自体を作る時など)
ための条件は以下の通り。</p>
<ul>
<li>通常のメモリロードストア命令ではなくアトミック命令を使い、
途中の状態を他のコアから観測されないようにする。</li>
<li>コンパイラ最適化を無効にし、特定の行をまたいだ命令の並べ替えを防止する。</li>
<li>メモリバリア命令を置き、それをまたいだ CPU 内での命令の並べ替えを防止する。</li>
</ul>
<p>volatile の付与だけでは全然足りないことが分かる。
通常のロードストア命令は自然にアトミックになる CPU も多いが。</p>
<p>コンパイラによるコンパイル時の並べ替えと CPU による実行時の並べ替えは、
いつやるかが違うだけで概念としては同じものが使える。
メモリの読み書きの (物理的な) 順番の制御をメモリオーダリングと呼び、
手動でそれを防ぐ手段をメモリバリアと呼ぶ。</p>
<p>ちなみに x86 はメモリオーダリングに関してはかなり「堅い」方で、ARM や RISC-V は
「ゆるゆる」である。
Google が Android のために JVM を x86 から ARM に持っていったら
怪奇現象にしか見えないメモリオーダリングのバグに苦労したらしい…。</p>
<h3 id="スリープロック-普通のロック"><a class="header" href="#スリープロック-普通のロック">スリープロック (普通のロック)</a></h3>
<h2 id="ロックフリーアルゴリズム-初心者お断り"><a class="header" href="#ロックフリーアルゴリズム-初心者お断り">ロックフリーアルゴリズム (初心者お断り)</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="nand.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="refer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="nand.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="refer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
